


<!DOCTYPE html>
<html lang="en">
  <head>
    <title>H.264 Quantization 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-zh-cn"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->

		<!-- mobile-bar 2-->
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>

	<!-- include header -->
    <div id="header">
  <a id="logo" href="/">
      <img src="/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>


<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/rstg00po54/modern-cpp-tutorial">GitHub</a>
</li>


  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
		<!-- body 111 -->
        



  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
        <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>


<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/rstg00po54/modern-cpp-tutorial">GitHub</a>
</li>


    </ul>
    <div class="list">
      <h2>
		
          正文

      </h2>
      <ul class="menu-root">
	  <!-- 引入外部的 JS 文件 -->
  <!-- <script src="/modern-cpp/js/menu.js"></script> -->


	<!-- 传递数据到 JavaScript -->
	
	
	

	
		<li>
		  <a href="/H264-BKY/2014-02-15-h.264%E7%9A%84poc%E8%AE%A1%E7%AE%97.html" class="sidebar-link">
			h.264的POC计算
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-02-27-%E6%8C%87%E6%95%B0%E5%93%A5%E4%BC%A6%E5%B8%83%E7%BC%96%E7%A0%81.html" class="sidebar-link">
			指数哥伦布编码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-15-h.264%E5%8A%A0%E6%9D%83%E9%A2%84%E6%B5%8B.html" class="sidebar-link">
			h.264加权预测
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-11-h.264%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6.html" class="sidebar-link">
			h.264码率控制
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-04-23-h.264%E7%9B%B4%E6%8E%A5%E9%A2%84%E6%B5%8B.html" class="sidebar-link">
			h.264直接预测
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-17-h.264-fmo.html" class="sidebar-link">
			h.264 FMO
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-05-11-h.264%E5%8F%82%E8%80%83%E5%9B%BE%E5%83%8F%E5%88%97%E8%A1%A8%E3%80%81%E8%A7%A3%E7%A0%81%E5%9B%BE%E5%83%8F%E7%BC%93%E5%AD%98.html" class="sidebar-link">
			h.264参考图像列表、解码图像缓存
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-06-h.264-mvp%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			h.264 mvp求解过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-16-umhexagons%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			UMHexagonS搜索过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-07-20-h.264%E5%85%A8%E6%90%9C%E7%B4%A2%E4%BB%A5%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%85%A8%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html" class="sidebar-link">
			h.264全搜索以及快速全搜索算法
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-18-h.264-%E7%8E%87%E5%A4%B1%E7%9C%9F%E4%BC%98%E5%8C%96.html" class="sidebar-link">
			h.264 率失真优化
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-10-17-epzs%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			EPZS搜索过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-12-07-intra-chroma-prediction.html" class="sidebar-link">
			Intra Chroma Prediction
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-12-28-intra-luma-prediction.html" class="sidebar-link">
			Intra Luma Prediction
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-01-13-h.264-transfor.html" class="sidebar-link">
			H.264 Transform
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-02-02-h.264-quantization.html" class="sidebar-link current">
			H.264 Quantization
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-04-06-quantization-method.html" class="sidebar-link">
			Quantization Method
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-04-26-h.264-mode-decision.html" class="sidebar-link">
			h.264 Mode Decision
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-05-17-h.264-bi-predictive-motion-searc.html" class="sidebar-link">
			h.264 Bi-Predictive Motion Search
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-02-24-h.264%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html" class="sidebar-link">
			h.264语法结构分析
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-02-29-h.264%E5%AE%8F%E5%9D%97%E4%B8%8E%E5%AD%90%E5%AE%8F%E5%9D%97%E7%B1%BB%E5%9E%8B.html" class="sidebar-link">
			h.264宏块与子宏块类型
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-05-h.264-scanning-process-for-transform-coefficients.html" class="sidebar-link">
			h.264 scanning process for transform coefficients
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-08-cavlc.html" class="sidebar-link">
			CAVLC
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-22-cabac.html" class="sidebar-link">
			CABAC
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-25-%E7%AE%97%E6%9C%AF%E7%BC%96%E7%A0%81jm%E5%AE%9E%E7%8E%B0.html" class="sidebar-link">
			算术编码JM实现
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-04-27-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html" class="sidebar-link">
			h.264并行解码算法分析
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-05-17-h.264-%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2.html" class="sidebar-link">
			h.264 去块滤波
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-08-11-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%952d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E9%9D%9E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法2D-Wave实现（基于多核非共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-09-18-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%952d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法2D-Wave实现（基于多核共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-09-30-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%953d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法3D-Wave实现（基于多核共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2017-04-04-h.264%E5%B9%B6%E8%A1%8C%E7%86%B5%E8%A7%A3%E7%A0%81.html" class="sidebar-link">
			h.264并行熵解码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2017-06-15-cabac%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A1%A5%E5%85%85%E8%AE%A8%E8%AE%BA.html" class="sidebar-link">
			CABAC总结与补充讨论
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2019-01-04-%5Bffmpeg%5D-h264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81.html" class="sidebar-link">
			ffmpeg h264并行解码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2019-01-24-%5Bffmpeg%5D-h.264%E8%A7%A3%E7%A0%81%E6%89%80%E7%94%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%8B%E7%BB%8D.html" class="sidebar-link">
			ffmpeg h.264解码所用的主要缓冲区介绍
		  </a>
		</li>


</ul>

	  
    </div>
  </div>
</div>

<link rel="stylesheet" href="../icon/iconfont.css">
<style>

/* body {
            background: #e4e9f5;
        } */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            list-style: none;
            text-decoration: none;
        }

        section {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font: 900 100px '';
            color: #ffa21759;
            background: rgb(34, 37, 39);
        }

        .shell {
            position: fixed;
            width: 60px;
			left: 0;
            height: 100%;
            background: #000000;
            z-index: 9999;
            transition: width 0.5s;
            /* padding-left: 10px; */
            overflow: hidden;
        }
/* 悬停改变宽度 */
        .shell:hover {
            width: 300px;
        }

        .imageBox {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            overflow: hidden;
        }

        .imageBox img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .shell ul {
            position: relative;
            height: 100vh;
        }

        .shell ul li {
            position: relative;
            padding: 5px;
        }

        .active {
            background: #e4e9f5;
            border-top-left-radius: 50px;
            border-bottom-left-radius: 50px;
        }

        .active::before {
            content: "";
            position: absolute;
            top: -30px;
            right: 0;
            width: 30px;
            height: 30px;
            border-bottom-right-radius: 25px;
            box-shadow: 5px 5px 0 5px #e4e9f5;
            background: transparent;
        }

        .active::after {
            content: "";
            position: absolute;
            bottom: -30px;
            right: 0;
            width: 30px;
            height: 30px;
            border-top-right-radius: 25px;
            box-shadow: 5px -5px 0 5px #e4e9f5;
            background: transparent;
        }

        #shelllogo {
            margin: 40px 0 100px 0;
        }

        .shell ul li a {
            position: relative;
            display: flex;
            white-space: nowrap;
        }

        .icon {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 40px;
            /* padding-left: 10px; */
            height: 70px;
            color: #333;
            transition: 0.5s;
            color: rgb(255, 255, 255);
        }

        .icon i {
            font-size: 30px;
            z-index: 999;
        }

        .text {
            position: relative;
            height: 70px;
            display: flex;
            align-items: center;
            font-size: 20px;
            color: #ffad32c1;
            padding-left: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.5s;
        }

        .shell ul li:hover a .icon,
        .shell ul li:hover a .text {
            color: #ffa117;
        }

        .active a .icon::before {
            content: "";
            position: absolute;
            inset: 5px;
            width: 60px;
            background: #000000;
            /* 圆形 */
            border-radius: 50%;
            transition: 0.5s;
            border: 7px solid #ffa117;
            box-sizing: border-box;
        }
</style>


<div class="shell">
	<ul class="nav">
		<li class="active" id="shelllogo">
			<a href="#">
				<div class="icon">
					<div class="imageBox">
						<img src="../icon/cat.jpg" alt="">
					</div>
				</div>
				<div class="text">前端小窝</div>
			</a>
		</li>
		<li>
			<a href="#home">
				<div class="icon">
					<i class="iconfont icon-cangku"></i>
				</div>
				<div class="text">Home</div>
			</a>
		</li>
		<li>
			<a href="#theme">
				<div class="icon">
					<!-- 调色板 -->
					<i class="iconfont icon-tiaoseban"></i>
				</div>
				<div class="text">Theme</div>
			</a>
		</li>
		<li>
			<a href="#wallet">
				<div class="icon">
					<!-- 钱包 -->
					<i class="iconfont icon-qianbao"></i>
				</div>
				<div class="text">Wallet</div>
			</a>
		</li>
		<li>
			<a href="#picture">
				<div class="icon">
					<!-- 图片 -->
					<i class="iconfont icon-tupian"></i>
				</div>
				<div class="text">picture</div>
			</a>
		</li>
		<li>
			<a href="#code">
				<div class="icon">
					<!-- 二维码 -->
					<i class="iconfont icon-erweima"></i>
				</div>
				<div class="text">QR code</div>
			</a>
		</li>
		<li>
			<a href="#authentication">
				<div class="icon">
					<!-- 盾牌保险认证 -->
					<i class="iconfont icon-dunpaibaoxianrenzheng"></i>
				</div>
				<div class="text">auth</div>
			</a>
		</li>
		<li>
			<a href="#me">
				<div class="icon">
					<div class="imageBox">
						<img src="./cat.jpg" alt="">
					</div>
				</div>
				<div class="text">ME</div>
			</a>
		</li>
	</ul>
</div>

<div class="content book-zh-cn with-sidebar 2015-02-02-h.264-quantization-guide">
  <h1 id="H-264-Quantizer"><a href="#H-264-Quantizer" class="headerlink" title="H.264 Quantizer"></a><strong>H.264 Quantizer</strong></h1><p>一般的量化器，可用下面的公式来表示：<br>$Z&#x3D;\pm \left \lfloor\frac{ \left | W \right | }{\bigtriangleup }\right \rfloor$<br>反量化可表示为：<br>$W’ &#x3D; \bigtriangleup \cdot Z$<br>量化步长$\bigtriangleup$决定了量化器的编码压缩率与图像精度。如果$\bigtriangleup$比较大，相应的编码长度较小，图像细节损失较多；如果$\bigtriangleup$比较小，相应的编码长度较大，图像损失细节较少。编码器需根据实际图像来改变$\bigtriangleup$值。</p>
<h1 id="Quantization-Offset"><a href="#Quantization-Offset" class="headerlink" title="Quantization Offset"></a><strong>Quantization Offset</strong></h1><p>可以看到，这种量化器是求下整，也就是会把区间$[0,\bigtriangleup)$的值量化成0。这种量化器显然不是最优的，最优的量化器在某区间上的量化值应该为该区间的期望值。为此需要知道残差变换系数的统计分布，这个分布是经过统计实验得出来的，其中帧间比帧内分布得更为集中。<br>为了表明分布集中于区间的期望值，引入了参数——offset（量化偏移量）$f$。相应的量化公式变为：<br>$Z&#x3D;\pm \left \lfloor\frac{ \left | W \right | + f }{\bigtriangleup }\right \rfloor$<br>反量化保持不变:<br>$W’ &#x3D;\pm (\bigtriangleup \cdot Z)$<br>H.264参考模型建议：当帧内预测时$f &#x3D; \bigtriangleup&#x2F;3$，帧间预测时$f &#x3D; \bigtriangleup&#x2F;6$。<br><img alt="" src="img/2015-02-02-h.264-quantization/020158477189605.jpg"></p>
<p>另外参数$f$可以控制量化死区（量化后为0区域）大小。<br><img alt="" src="img/2015-02-02-h.264-quantization/020158502962294.jpg"><br>当$f$变大时，量化死区减少；当$f$变小时，量化死区增加。死区大小可以直接影响到视频图像的主观质量。变换后，图像高频部分的数值比较小，也就是说离0值比较接近。如果死区比较大，0值附近的值会被量化为0，则图像会损失这些细节。这个特性在电影中特别有用：在电影胶片上会随机分布着一些斑点，这些斑点是胶片化学物质的结晶体，由于这些斑点与视频的内容在时间、空间上的不相关性，其值没法在预测模块中预测到。因此这些斑点表现为变换后的一些小的高频系数。为了消除这些斑点，可取较小的$f$值，这样量化死区就会较大。在字幕区域的细节比较多，可对字幕区域取比较大的$f$值。<br>从上方的例子可以看出，死区特征的应用是与应用直接相关的，最好能根据不同的应用相应加以调整。<br>我们注意到通过参数$f$可以控制量化区间的偏移，以及控制死区大小。两者耦合在一起了。JVT-K026有个直接的解耦方法：加入一个新的参数$\Theta$来控制量化死区的大小，并将量化公式修改为：<br>$ Z&#x3D;\pm \left \lfloor\frac{ \left | W \right | + \Theta + f }{\bigtriangleup }\right \rfloor $<br>$ W’ &#x3D; \pm (\bigtriangleup \cdot Z - \Theta) $<br>但是这种方法并没有被标准采用。</p>
<h1 id="Quantization-Step"><a href="#Quantization-Step" class="headerlink" title="Quantization Step"></a><strong>Quantization Step</strong></h1><p>H．264标准共设计了52个不同的量化步长$Q_{step}$，如下表所示，其中QP是量化参数，也就是量化步长的序号。QP由小变大，意味着量化步长的增大，也就是由精细变粗糙。</p>
<p>$Q_{step}$变化有明显的规律：QP每增加1，量化步长就增加12.25%（即$\sqrt[6]{2}-1$）;QP每增加6，量化步长就增加一倍，即$Q_{step}(QP+6) &#x3D; 2Q_{step}(QP)$。这样做就可以显著减少量化表与反量化表的大小，仅用0~5这6个QP的$Q_{step}$，通过右移就可以得到剩下所有的$Q_{step}$，即$Q_{step}(QP) &#x3D; Q_{step}(QP%6) \cdot 2^{QP&#x2F;6}$。<br>在讲述变换的时候说过，变换的$\bigotimes$运算矩阵$E_f$可以合并到量化表中。下面来看一下该运算矩阵<br>$ E_f[i][j] &#x3D; \begin{bmatrix} a^2 &amp; \frac{1}{2}ab &amp; a^2 &amp; \frac{1}{2}ab\ \frac{1}{2}ab &amp; \frac{1}{4}b^2 &amp; \frac{1}{2}ab &amp; \frac{1}{4}b^2\ a^2 &amp; \frac{1}{2}ab &amp; a^2 &amp; \frac{1}{2}ab\ \frac{1}{2}ab &amp; \frac{1}{4}b^2 &amp; \frac{1}{2}ab &amp; \frac{1}{4}b^2 \end{bmatrix}$<br>得到量化矩阵所进行的合并运算如下(归一化为$2^{15}$)<br>$\begin{align*}Q(QP,i,j) &amp;&#x3D; \frac{E_f[i][j]}{Q_{step}(QP)}\times 2^{15+QP&#x2F;6} \ &amp;&#x3D; \frac{E_f[i][j]}{Q_{step}(QP%6)\times 2^{QP&#x2F;6}} \times 2^{15+QP&#x2F;6} \ &amp;&#x3D; \frac{E_f[i][j]}{Q_{step}(QP%6)} \cdot 2^{15}\end{align*}$<br>上式表明$Q(QP,i,j) &#x3D; Q(QP%6,i,j)$<br>以$Q(0,0,0) $为例，<br>$\begin{align*}Q(0,0,0) &amp;&#x3D; \frac{a^2}{Q_{step}(QP)} \times 2^{15} \ &amp;&#x3D; \frac{0.25}{0.625}\times 2^{15} \ &amp;&#x3D; 13107 \end{align*}$</p>
<p>把0~5这6个QP的$Q_{step}$分别与$\bigotimes$运算矩阵$E_f$合并后，可以得到以下6个矩阵，即$Q(QP%6,i,j)$</p>
<p>$Q(0,i,j) &#x3D; \begin{bmatrix}13107 &amp; 8066&amp;13107&amp; 8066\ 8066&amp; 5243&amp; 8066&amp; 5243\13107&amp; 8066&amp;13107&amp; 8066\ 8066&amp; 5243&amp; 8066&amp; 5243 \end{bmatrix}$<br>$Q(1,i,j) &#x3D;\begin{bmatrix}11916&amp; 7490&amp;11916&amp; 7490\ 7490&amp; 4660&amp; 7490&amp; 4660\11916&amp; 7490&amp;11916&amp; 7490\ 7490&amp; 4660&amp; 7490&amp; 4660\end{bmatrix}$<br>$Q(2,i,j)&#x3D; \begin{bmatrix}10082&amp; 6554&amp;10082&amp; 6554\ 6554&amp; 4194&amp; 6554&amp; 4194\10082&amp; 6554&amp;10082&amp; 6554\ 6554&amp; 4194&amp; 6554&amp; 4194\end{bmatrix}$<br>$Q(3,i,j) &#x3D;\begin{bmatrix} 9362&amp; 5825&amp; 9362&amp; 5825\ 5825&amp; 3647&amp; 5825&amp; 3647\ 9362&amp; 5825&amp; 9362&amp; 5825\ 5825&amp; 3647&amp; 5825&amp; 3647\end{bmatrix} $<br>$Q(4,i,j) &#x3D;\begin{bmatrix} 8192&amp; 5243&amp; 8192&amp; 5243\ 5243&amp; 3355&amp; 5243&amp; 3355\ 8192&amp; 5243&amp; 8192&amp; 5243\ 5243&amp; 3355&amp; 5243&amp; 3355\end{bmatrix} $<br>$Q(5,i,j) &#x3D;\begin{bmatrix} 7282&amp; 4559&amp; 7282&amp; 4559\ 4559&amp; 2893&amp; 4559&amp; 2893\ 7282&amp; 4559&amp; 7282&amp; 4559\ 4559&amp; 2893&amp; 4559&amp; 2893\end{bmatrix}$</p>
<p>在$E_f$矩阵中，可以看到里面有3个数值$a^2, ab, b^2$，合并到量化矩阵后，就有$3 \times 52 &#x3D; 156$个参数。采用了上面的QP每增加6，量化步长增加一倍的方法后，参数就只有$3 \times 6 &#x3D; 18$个参数：<br>$QuantMatrix[6][3] &#x3D; \begin{bmatrix}13107 &amp; 5243 &amp; 8066 \11916 &amp; 4660 &amp; 7490 \10082 &amp; 4194 &amp; 6554 \9362 &amp; 3647 &amp; 5825 \8192 &amp; 3355 &amp; 5243 \7282 &amp; 2893 &amp; 4559\end{bmatrix}$</p>
<p>采用量化矩阵的方式后，4x4整数DCT变换的量化公式为</p>
<p>$\begin{align*}Z_{ij} &amp;&#x3D; \frac{Y_{ij}\bigotimes E_f[i][j] + f’}{Q_{step}(QP)} \ &amp;&#x3D; \frac{Y_{ij}\bigotimes E_f[i][j] + f}{Q_{step}(QP%6)} \div 2^{QP&#x2F;6} \ &amp;&#x3D; Y_{ij}\bigotimes Q(QP%6,i,j) \div 2^{15+QP&#x2F;6}\end{align*}$</p>
<p>同样道理，逆量化矩阵为(归一化为$2^{10}$)：<br>$\begin{align*}R(QP,i,j) &amp;&#x3D; E^R_f[i][j] \times Q_{step}(QP) \times 2^{10-QP&#x2F;6} \ &amp;&#x3D; E^R_f[i][j] \times Q_{step}(QP%6) \times 2^{QP&#x2F;6} \times 2^{10-QP&#x2F;6} \ &amp;&#x3D; E^R_f[i][j] \times Q_{step}(QP%6) \times 2^{10}\end{align*}$<br>上式表明$R(QP,i,j) &#x3D; R(QP%6,i,j)$<br>逆量化公式为：<br>$\begin{align*}Y’<em>{ij} &amp;&#x3D; Z</em>{ij}\bigotimes E^R_f[i][j] \times Q_{step} \&amp;&#x3D; Z_{ij} \bigotimes R(QP%6,i,j) \div {2^{10-QP&#x2F;6}}\end{align*}$<br>逆量化矩阵为<br>$dequantMat[6][3]&#x3D; \begin{bmatrix} 160 &amp; 256 &amp; 208\ 176 &amp; 288 &amp; 224\ 208 &amp; 320 &amp; 256\224 &amp; 368 &amp; 288\ 256 &amp; 400 &amp; 320\ 288 &amp; 464 &amp; 368\end{bmatrix}$</p>
<h1 id="Nonuniformity-Quantization"><a href="#Nonuniformity-Quantization" class="headerlink" title="Nonuniformity Quantization"></a><strong>Nonuniformity Quantization</strong></h1><p>非一致性量化就是4x4或8x8矩阵上各个位置的量化权重不同，通过这种方法可以在进行量化之前调整量化步长，得到更适合人类视觉系统，更真实的图像。<br>加入权重矩阵$W_{ij}$后，量化矩阵与逆量化矩阵分别为：<br>$Q(QP,i,j) &#x3D; \frac{1}{W_{ij}}\cdot \frac{E_f[i][j]}{Q_{step}(QP%6)}\times 2^{15+QP&#x2F;6}$<br>$ R(QP,i,j) &#x3D; W_{ij} \cdot E^R_f[i][j] \times Q_{step}(QP%6) \times 2^{10-QP&#x2F;6}$<br>其中$W_{ij}$会被归一为16，即$2&lt;&lt;4$</p>
<p>JM18.6参考代码如下<br>量化矩阵：<br><img alt="" src="img/2015-02-02-h.264-quantization/ContractedBlock.gif"><img alt="" src="img/2015-02-02-h.264-quantization/ExpandedBlockStart.gif">&#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>For calculating the quantisation values at frame level</li>
<li></li>
<li>\par Input:</li>
<li>none</li>
<li></li>
<li>\par Output:</li>
<li>none</li>
</ul>
<p> *************************************************************************&#x2F;voidCalculateQuant4x4Param(VideoParameters <em>p_Vid)<br>{<br>  QuantParameters</em>p_Quant  &#x3D; p_Vid-&gt;p_Quant;<br>  ScaleParameters*p_QScale &#x3D; p_Vid-&gt;p_QScale;</p>
<p>  pic_parameter_set_rbsp_t<em>active_pps &#x3D; p_Vid-&gt;active_pps;<br>  seq_parameter_set_rbsp_t</em>active_sps &#x3D; p_Vid-&gt;active_sps;inti, j, k, temp;intk_mod;intpresent[6];intno_q_matrix&#x3D;FALSE;&#x2F;&#x2F;FALSE means donot use default quant ,use weight qp on config files (quantMat &lt;&lt; 4 &#x2F; weight)intmax_bitdepth &#x3D; imax(p_Vid-&gt;bitdepth_luma, p_Vid-&gt;bitdepth_chroma);intmax_qp &#x3D; (3+6*(max_bitdepth));if(!active_sps-&gt;seq_scaling_matrix_present_flag &amp;&amp; !active_pps-&gt;pic_scaling_matrix_present_flag)&#x2F;&#x2F;set to no q-matrixno_q_matrix&#x3D;TRUE;else{<br>    memset(present,0,6*sizeof(int));if(active_sps-&gt;seq_scaling_matrix_present_flag)for(i&#x3D;0; i&lt;6; i++)<br>        present[i]&#x3D; active_sps-&gt;seq_scaling_list_present_flag[i];if(active_pps-&gt;pic_scaling_matrix_present_flag)for(i&#x3D;0; i&lt;6; i++)<br>      {if((i&#x3D;&#x3D;0) || (i&#x3D;&#x3D;3))<br>          present[i]|&#x3D; active_pps-&gt;pic_scaling_list_present_flag[i];elsepresent[i]&#x3D; active_pps-&gt;pic_scaling_list_present_flag[i];<br>      }<br>  }if(no_q_matrix&#x3D;&#x3D;TRUE)&#x2F;&#x2F;normal quant{for(k_mod &#x3D;0; k_mod &lt;&#x3D; max_qp; k_mod++)<br>    {<br>      k&#x3D; k_mod %6;<br>      set_default_quant4x4(p_Quant-&gt;q_params_4x4[0][0][k_mod],  quant_coef[k], dequant_coef[k]);<br>      set_default_quant4x4(p_Quant-&gt;q_params_4x4[0][1][k_mod],  quant_coef[k], dequant_coef[k]);<br>      set_default_quant4x4(p_Quant-&gt;q_params_4x4[1][0][k_mod],  quant_coef[k], dequant_coef[k]);<br>      set_default_quant4x4(p_Quant-&gt;q_params_4x4[1][1][k_mod],  quant_coef[k], dequant_coef[k]);<br>      set_default_quant4x4(p_Quant-&gt;q_params_4x4[2][0][k_mod],  quant_coef[k], dequant_coef[k]);<br>      set_default_quant4x4(p_Quant-&gt;q_params_4x4[2][1][k_mod],  quant_coef[k], dequant_coef[k]);<br>    }<br>  }else&#x2F;&#x2F;weight quant{for(k_mod &#x3D;0; k_mod &lt;&#x3D; max_qp; k_mod++)<br>    {<br>      k&#x3D; k_mod %6;for(j&#x3D;0; j&lt;4; j++)<br>      {for(i&#x3D;0; i&lt;4; i++)<br>        {<br>          temp&#x3D; (j&lt;&lt;2)+i;&#x2F;&#x2F;present means we use the weight quant on the file q_matrix.cfgif((!present[0]) || p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[0])<br>          {<br>            p_Quant-&gt;q_params_4x4[0][1][k_mod][j][i].ScaleComp    &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;Quant_intra_default[temp];<br>            p_Quant-&gt;q_params_4x4[0][1][k_mod][j][i].InvScaleComp &#x3D; dequant_coef[k][j][i]<em>Quant_intra_default[temp];<br>          }else{<br>            p_Quant-&gt;q_params_4x4[0][1][k_mod][j][i].ScaleComp    &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;p_QScale-&gt;ScalingList4x4[0][temp];<br>            p_Quant-&gt;q_params_4x4[0][1][k_mod][j][i].InvScaleComp &#x3D; dequant_coef[k][j][i]<em>p_QScale-&gt;ScalingList4x4[0][temp];<br>          }if(!present[1])<br>          {<br>            p_Quant-&gt;q_params_4x4[1][1][k_mod][j][i].ScaleComp    &#x3D; p_Quant-&gt;q_params_4x4[0][1][k_mod][j][i].ScaleComp;<br>            p_Quant-&gt;q_params_4x4[1][1][k_mod][j][i].InvScaleComp &#x3D; p_Quant-&gt;q_params_4x4[0][1][k_mod][j][i].InvScaleComp;<br>          }else{<br>            p_Quant-&gt;q_params_4x4[1][1][k_mod][j][i].ScaleComp    &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[1] ? Quant_intra_default[temp]:p_QScale-&gt;ScalingList4x4[1][temp]);<br>            p_Quant-&gt;q_params_4x4[1][1][k_mod][j][i].InvScaleComp &#x3D; dequant_coef[k][j][i]</em>(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[1] ? Quant_intra_default[temp]:p_QScale-&gt;ScalingList4x4[1][temp]);<br>          }if(!present[2])<br>          {<br>            p_Quant-&gt;q_params_4x4[2][1][k_mod][j][i].ScaleComp    &#x3D; p_Quant-&gt;q_params_4x4[1][1][k_mod][j][i].ScaleComp;<br>            p_Quant-&gt;q_params_4x4[2][1][k_mod][j][i].InvScaleComp &#x3D; p_Quant-&gt;q_params_4x4[1][1][k_mod][j][i].InvScaleComp;<br>          }else{<br>            p_Quant-&gt;q_params_4x4[2][1][k_mod][j][i].ScaleComp    &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[2] ? Quant_intra_default[temp]:p_QScale-&gt;ScalingList4x4[2][temp]);<br>            p_Quant-&gt;q_params_4x4[2][1][k_mod][j][i].InvScaleComp &#x3D; dequant_coef[k][j][i]</em>(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[2] ? Quant_intra_default[temp]:p_QScale-&gt;ScalingList4x4[2][temp]);<br>          }if((!present[3]) || p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[3])<br>          {<br>            p_Quant-&gt;q_params_4x4[0][0][k_mod][j][i].ScaleComp         &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;Quant_inter_default[temp];<br>            p_Quant-&gt;q_params_4x4[0][0][k_mod][j][i].InvScaleComp      &#x3D; dequant_coef[k][j][i]<em>Quant_inter_default[temp];<br>          }else{<br>            p_Quant-&gt;q_params_4x4[0][0][k_mod][j][i].ScaleComp         &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;p_QScale-&gt;ScalingList4x4[3][temp];<br>            p_Quant-&gt;q_params_4x4[0][0][k_mod][j][i].InvScaleComp      &#x3D; dequant_coef[k][j][i]<em>p_QScale-&gt;ScalingList4x4[3][temp];<br>          }if(!present[4])<br>          {<br>            p_Quant-&gt;q_params_4x4[1][0][k_mod][j][i].ScaleComp    &#x3D; p_Quant-&gt;q_params_4x4[0][0][k_mod][j][i].ScaleComp;<br>            p_Quant-&gt;q_params_4x4[1][0][k_mod][j][i].InvScaleComp &#x3D; p_Quant-&gt;q_params_4x4[0][0][k_mod][j][i].InvScaleComp;<br>          }else{<br>            p_Quant-&gt;q_params_4x4[1][0][k_mod][j][i].ScaleComp    &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[4] ? Quant_inter_default[temp]:p_QScale-&gt;ScalingList4x4[4][temp]);<br>            p_Quant-&gt;q_params_4x4[1][0][k_mod][j][i].InvScaleComp &#x3D; dequant_coef[k][j][i]</em>(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[4] ? Quant_inter_default[temp]:p_QScale-&gt;ScalingList4x4[4][temp]);<br>          }if(!present[5])<br>          {<br>            p_Quant-&gt;q_params_4x4[2][0][k_mod][j][i].ScaleComp    &#x3D; p_Quant-&gt;q_params_4x4[1][0][k_mod][j][i].ScaleComp;<br>            p_Quant-&gt;q_params_4x4[2][0][k_mod][j][i].InvScaleComp &#x3D; p_Quant-&gt;q_params_4x4[1][0][k_mod][j][i].InvScaleComp;<br>          }else{<br>            p_Quant-&gt;q_params_4x4[2][0][k_mod][j][i].ScaleComp    &#x3D; (quant_coef[k][j][i]&lt;&lt;4)&#x2F;(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[5] ? Quant_inter_default[temp]:p_QScale-&gt;ScalingList4x4[5][temp]);<br>            p_Quant-&gt;q_params_4x4[2][0][k_mod][j][i].InvScaleComp &#x3D; dequant_coef[k][j][i]</em>(p_QScale-&gt;UseDefaultScalingMatrix4x4Flag[5] ? Quant_inter_default[temp]:p_QScale-&gt;ScalingList4x4[5][temp]);<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p>
<p>View Code</p>
<p>量化偏移矩阵<br><img alt="" src="img/2015-02-02-h.264-quantization/ContractedBlock.gif"><img alt="" src="img/2015-02-02-h.264-quantization/ExpandedBlockStart.gif">&#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Init quantization offset parameters</li>
<li></li>
<li>\par Input:</li>
<li>none</li>
<li></li>
<li>\par Output:</li>
<li>none</li>
</ul>
<p> *************************************************************************&#x2F;voidInitOffsetParam (QuantParameters <em>p_Quant, InputParameters <em>p_Inp)<br>{inti, k;intmax_qp_luma &#x3D; (4+6</em>(p_Inp-&gt;output.bit_depth[0]));intmax_qp_cr   &#x3D; (4+6</em>(p_Inp-&gt;output.bit_depth[1]));for(i &#x3D;0; i &lt; (p_Inp-&gt;AdaptRoundingFixed ?1: imax(max_qp_luma, max_qp_cr)); i++)<br>  {if(p_Inp-&gt;OffsetMatrixPresentFlag)<br>    {<br>      memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][0][0]),&amp;(p_Quant-&gt;OffsetList4x4input[0][0]),400<em>sizeof(short));&#x2F;&#x2F;25 * 16memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][0][0]),&amp;(p_Quant-&gt;OffsetList8x8input[0][0]),960</em>sizeof(short));&#x2F;&#x2F;15 * 64}else{if(p_Inp-&gt;OffsetMatrixFlat &#x3D;&#x3D;1)<br>      {&#x2F;&#x2F;0 (INTRA4X4_LUMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][0][0]),&amp;(Offset_intra_flat_intra[0]),16<em>sizeof(short));for(k &#x3D;1; k &lt;3; k++)&#x2F;&#x2F;1,2 (INTRA4X4_CHROMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_flat_chroma[0]),16</em>sizeof(short));for(k &#x3D;3; k &lt;9; k++)&#x2F;&#x2F;3,4,5,6,7,8 (INTRA4X4_LUMA&#x2F;CHROMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_flat_inter[0]),16<em>sizeof(short));for(k &#x3D;9; k &lt;25; k++)&#x2F;&#x2F;9,10,11,12,13,14 (INTER4X4)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_inter_flat[0]),16</em>sizeof(short));&#x2F;&#x2F;0 (INTRA8X8_LUMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][0][0]),&amp;(Offset8_intra_flat_intra[0]),64<em>sizeof(short));for(k &#x3D;1; k &lt;3; k++)&#x2F;&#x2F;1,2 (INTRA8X8_LUMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_flat_inter[0]),64</em>sizeof(short));for(k &#x3D;3; k &lt;5; k++)&#x2F;&#x2F;3,4 (INTER8X8_LUMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_flat[0]),64<em>sizeof(short));&#x2F;&#x2F;5 (INTRA8X8_CHROMAU_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][5][0]),&amp;(Offset8_intra_flat_chroma[0]),64</em>sizeof(short));for(k &#x3D;6; k &lt;8; k++)&#x2F;&#x2F;6,7 (INTRA8X8_CHROMAU_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_flat_inter[0]),64<em>sizeof(short));for(k &#x3D;8; k &lt;10; k++)&#x2F;&#x2F;8,9 (INTER8X8_CHROMAU_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_flat[0]),64</em>sizeof(short));&#x2F;&#x2F;10 (INTRA8X8_CHROMAV_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][10][0]),&amp;(Offset8_intra_flat_chroma[0]),64<em>sizeof(short));for(k &#x3D;11; k &lt;13; k++)&#x2F;&#x2F;11,12 (INTRA8X8_CHROMAV_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_flat_inter[0]),64</em>sizeof(short));for(k &#x3D;13; k &lt;15; k++)&#x2F;&#x2F;8,9 (INTER8X8_CHROMAV_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_flat[0]),64<em>sizeof(short));<br>      }elseif(p_Inp-&gt;OffsetMatrixFlat &#x3D;&#x3D;2)<br>      {&#x2F;&#x2F;0 (INTRA4X4_LUMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][0][0]),&amp;(Offset_intra_default_intra[0]),16</em>sizeof(short));for(k &#x3D;1; k &lt;3; k++)&#x2F;&#x2F;1,2 (INTRA4X4_CHROMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_flat_chroma[0]),16<em>sizeof(short));<br>        memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][3][0]),&amp;(Offset_intra_default_inter[0]),16</em>sizeof(short));for(k &#x3D;4; k &lt;6; k++)&#x2F;&#x2F;4,5 (INTRA4X4_CHROMA_INTERP)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_flat_inter[0]),16<em>sizeof(short));<br>        memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][6][0]),&amp;(Offset_intra_default_inter[0]),16</em>sizeof(short));for(k &#x3D;7; k &lt;9; k++)&#x2F;&#x2F;7,8 (INTRA4X4_CHROMA_INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_flat_inter[0]),16<em>sizeof(short));for(k &#x3D;9; k &lt;25; k++)&#x2F;&#x2F;9,10,11,12,13,14 (INTER4X4)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_inter_default[0]),16</em>sizeof(short));&#x2F;&#x2F;0 (INTRA8X8_LUMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][0][0]),&amp;(Offset8_intra_default_intra[0]),64<em>sizeof(short));for(k &#x3D;1; k &lt;3; k++)&#x2F;&#x2F;1,2 (INTRA8X8_LUMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_default_inter[0]),64</em>sizeof(short));for(k &#x3D;3; k &lt;5; k++)&#x2F;&#x2F;3,4 (INTER8X8_LUMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_default[0]),64<em>sizeof(short));&#x2F;&#x2F;5 (INTRA8X8_CHROMAU_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][5][0]),&amp;(Offset8_intra_flat_chroma[0]),64</em>sizeof(short));for(k &#x3D;6; k &lt;8; k++)&#x2F;&#x2F;6,7 (INTRA8X8_CHROMAU_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_flat_inter[0]),64<em>sizeof(short));for(k &#x3D;8; k &lt;10; k++)&#x2F;&#x2F;8,9 (INTER8X8_CHROMAU_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_default[0]),64</em>sizeof(short));&#x2F;&#x2F;10 (INTRA8X8_CHROMAV_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][10][0]),&amp;(Offset8_intra_flat_chroma[0]),64<em>sizeof(short));for(k &#x3D;11; k &lt;13; k++)&#x2F;&#x2F;11,12 (INTRA8X8_CHROMAV_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_flat_inter[0]),64</em>sizeof(short));for(k &#x3D;13; k &lt;15; k++)&#x2F;&#x2F;8,9 (INTER8X8_CHROMAV_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_default[0]),64<em>sizeof(short));<br>      }else{&#x2F;&#x2F;0 (INTRA4X4_LUMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][0][0]),&amp;(Offset_intra_default_intra[0]),16</em>sizeof(short));for(k &#x3D;1; k &lt;3; k++)&#x2F;&#x2F;1,2 (INTRA4X4_CHROMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_default_chroma[0]),16<em>sizeof(short));for(k &#x3D;3; k &lt;9; k++)&#x2F;&#x2F;3,4,5,6,7,8 (INTRA4X4_LUMA&#x2F;CHROMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_intra_default_inter[0]),16</em>sizeof(short));for(k &#x3D;9; k &lt;25; k++)&#x2F;&#x2F;9,10,11,12,13,14 (INTER4X4)memcpy(&amp;(p_Quant-&gt;OffsetList4x4[i][k][0]),&amp;(Offset_inter_default[0]),16<em>sizeof(short));&#x2F;&#x2F;0 (INTRA8X8_LUMA_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][0][0]),&amp;(Offset8_intra_default_intra[0]),64</em>sizeof(short));for(k &#x3D;1; k &lt;3; k++)&#x2F;&#x2F;1,2 (INTRA8X8_LUMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_default_inter[0]),64<em>sizeof(short));for(k &#x3D;3; k &lt;5; k++)&#x2F;&#x2F;3,4 (INTER8X8_LUMA_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_default[0]),64</em>sizeof(short));&#x2F;&#x2F;5 (INTRA8X8_CHROMAU_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][5][0]),&amp;(Offset8_intra_default_chroma[0]),64<em>sizeof(short));for(k &#x3D;6; k &lt;8; k++)&#x2F;&#x2F;6,7 (INTRA8X8_CHROMAU_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_default_inter[0]),64</em>sizeof(short));for(k &#x3D;8; k &lt;10; k++)&#x2F;&#x2F;8,9 (INTER8X8_CHROMAU_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_default[0]),64<em>sizeof(short));&#x2F;&#x2F;10 (INTRA8X8_CHROMAV_INTRA)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][10][0]),&amp;(Offset8_intra_default_chroma[0]),64</em>sizeof(short));for(k &#x3D;11; k &lt;13; k++)&#x2F;&#x2F;11,12 (INTRA8X8_CHROMAV_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_intra_default_inter[0]),64<em>sizeof(short));for(k &#x3D;13; k &lt;15; k++)&#x2F;&#x2F;8,9 (INTER8X8_CHROMAV_INTERP&#x2F;INTERB)memcpy(&amp;(p_Quant-&gt;OffsetList8x8[i][k][0]),&amp;(Offset8_inter_default[0]),64</em>sizeof(short));<br>      }<br>    }<br>  }<br>}&#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Calculation of the quantization offset parameters at the frame level</li>
<li></li>
<li>\par Input:</li>
<li>none</li>
<li></li>
<li>\par Output:</li>
<li>none</li>
</ul>
<p> *************************************************************************&#x2F;voidCalculateOffset4x4Param (VideoParameters <em>p_Vid)<br>{<br>  QuantParameters</em>p_Quant &#x3D; p_Vid-&gt;p_Quant;intk;intqp_per, qp;intimg_type &#x3D; ((p_Vid-&gt;type &#x3D;&#x3D; SI_SLICE) ? I_SLICE : (p_Vid-&gt;type &#x3D;&#x3D; SP_SLICE ? P_SLICE : p_Vid-&gt;type));intmax_qp_scale &#x3D; imax(p_Vid-&gt;bitdepth_luma_qp_scale, p_Vid-&gt;bitdepth_chroma_qp_scale);intmax_qp &#x3D;51+max_qp_scale;<br>  InputParameters*p_Inp &#x3D; p_Vid-&gt;p_Inp;</p>
<p>  p_Vid-&gt;AdaptRndWeight   &#x3D; p_Inp-&gt;AdaptRndWFactor  [p_Vid-&gt;nal_reference_idc !&#x3D;0][img_type];<br>  p_Vid-&gt;AdaptRndCrWeight &#x3D; p_Inp-&gt;AdaptRndCrWFactor[p_Vid-&gt;nal_reference_idc !&#x3D;0][img_type];if(img_type &#x3D;&#x3D;I_SLICE )<br>  {for(qp &#x3D;0; qp &lt; max_qp +1; qp++)<br>    {<br>      k&#x3D; p_Quant-&gt;qp_per_matrix [qp];<br>      qp_per&#x3D; Q_BITS + k -OffsetBits;<br>      k&#x3D; p_Inp-&gt;AdaptRoundingFixed ?0: qp;&#x2F;&#x2F;Intra4x4 lumaupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[0][1][qp], p_Quant-&gt;OffsetList4x4[k][0], qp_per);&#x2F;&#x2F;Intra4x4 chroma uupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[1][1][qp], p_Quant-&gt;OffsetList4x4[k][1], qp_per);&#x2F;&#x2F;Intra4x4 chroma vupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[2][1][qp], p_Quant-&gt;OffsetList4x4[k][2], qp_per);<br>    }<br>  }elseif(img_type &#x3D;&#x3D;B_SLICE)<br>  {for(qp &#x3D;0; qp &lt; max_qp +1; qp++)<br>    {<br>      k&#x3D; p_Quant-&gt;qp_per_matrix [qp];<br>      qp_per&#x3D; Q_BITS + k -OffsetBits;<br>      k&#x3D; p_Inp-&gt;AdaptRoundingFixed ?0: qp;&#x2F;&#x2F;Inter4x4 lumaupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[0][0][qp], p_Quant-&gt;OffsetList4x4[k][12], qp_per);&#x2F;&#x2F;Intra4x4 lumaupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[0][1][qp], p_Quant-&gt;OffsetList4x4[k][6], qp_per);&#x2F;&#x2F;Inter4x4 chroma uupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[1][0][qp], p_Quant-&gt;OffsetList4x4[k][13], qp_per);&#x2F;&#x2F;Intra4x4 chroma uupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[1][1][qp], p_Quant-&gt;OffsetList4x4[k][7], qp_per);&#x2F;&#x2F;Inter4x4 chroma vupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[2][0][qp], p_Quant-&gt;OffsetList4x4[k][14], qp_per);&#x2F;&#x2F;Intra4x4 chroma vupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[2][1][qp], p_Quant-&gt;OffsetList4x4[k][8], qp_per);<br>    }<br>  }else{for(qp &#x3D;0; qp &lt; max_qp +1; qp++)<br>    {<br>      k&#x3D; p_Quant-&gt;qp_per_matrix [qp];<br>      qp_per&#x3D; Q_BITS + k -OffsetBits;<br>      k&#x3D; p_Inp-&gt;AdaptRoundingFixed ?0: qp;&#x2F;&#x2F;Inter4x4 lumaupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[0][0][qp], p_Quant-&gt;OffsetList4x4[k][9], qp_per);&#x2F;&#x2F;Intra4x4 lumaupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[0][1][qp], p_Quant-&gt;OffsetList4x4[k][3], qp_per);&#x2F;&#x2F;Inter4x4 chroma uupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[1][0][qp], p_Quant-&gt;OffsetList4x4[k][10], qp_per);&#x2F;&#x2F;Intra4x4 chroma uupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[1][1][qp], p_Quant-&gt;OffsetList4x4[k][4], qp_per);&#x2F;&#x2F;Inter4x4 chroma vupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[2][0][qp], p_Quant-&gt;OffsetList4x4[k][11], qp_per);&#x2F;&#x2F;Intra4x4 chroma vupdate_q_offset4x4(p_Quant-&gt;q_params_4x4[2][1][qp], p_Quant-&gt;OffsetList4x4[k][5], qp_per);<br>    }<br>  }<br>}</p>
<p>View Code</p>

  <div class="guide-links">
    
    
  </div>

    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">欧长坤</a> &copy; 2016-2025 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>



</div>

	</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
