


<!DOCTYPE html>
<html lang="en">
  <head>
    <title>h.264 Bi-Predictive Motion Search 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-zh-cn"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->

		<!-- mobile-bar 2-->
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>

	<!-- include header -->
    <div id="header">
  <a id="logo" href="/">
      <img src="/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>


<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/rstg00po54/modern-cpp-tutorial">GitHub</a>
</li>


  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
		<!-- body 111 -->
        



  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
        <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>


<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/rstg00po54/modern-cpp-tutorial">GitHub</a>
</li>


    </ul>
    <div class="list">
      <h2>
		
          正文

      </h2>
      <ul class="menu-root">
	  <!-- 引入外部的 JS 文件 -->
  <!-- <script src="/modern-cpp/js/menu.js"></script> -->


	<!-- 传递数据到 JavaScript -->
	
	
	

	
		<li>
		  <a href="/H264-BKY/2014-02-15-h.264%E7%9A%84poc%E8%AE%A1%E7%AE%97.html" class="sidebar-link">
			h.264的POC计算
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-02-27-%E6%8C%87%E6%95%B0%E5%93%A5%E4%BC%A6%E5%B8%83%E7%BC%96%E7%A0%81.html" class="sidebar-link">
			指数哥伦布编码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-15-h.264%E5%8A%A0%E6%9D%83%E9%A2%84%E6%B5%8B.html" class="sidebar-link">
			h.264加权预测
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-11-h.264%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6.html" class="sidebar-link">
			h.264码率控制
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-04-23-h.264%E7%9B%B4%E6%8E%A5%E9%A2%84%E6%B5%8B.html" class="sidebar-link">
			h.264直接预测
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-17-h.264-fmo.html" class="sidebar-link">
			h.264 FMO
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-05-11-h.264%E5%8F%82%E8%80%83%E5%9B%BE%E5%83%8F%E5%88%97%E8%A1%A8%E3%80%81%E8%A7%A3%E7%A0%81%E5%9B%BE%E5%83%8F%E7%BC%93%E5%AD%98.html" class="sidebar-link">
			h.264参考图像列表、解码图像缓存
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-06-h.264-mvp%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			h.264 mvp求解过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-16-umhexagons%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			UMHexagonS搜索过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-07-20-h.264%E5%85%A8%E6%90%9C%E7%B4%A2%E4%BB%A5%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%85%A8%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html" class="sidebar-link">
			h.264全搜索以及快速全搜索算法
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-18-h.264-%E7%8E%87%E5%A4%B1%E7%9C%9F%E4%BC%98%E5%8C%96.html" class="sidebar-link">
			h.264 率失真优化
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-10-17-epzs%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			EPZS搜索过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-12-07-intra-chroma-prediction.html" class="sidebar-link">
			Intra Chroma Prediction
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-12-28-intra-luma-prediction.html" class="sidebar-link">
			Intra Luma Prediction
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-01-13-h.264-transfor.html" class="sidebar-link">
			H.264 Transform
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-02-02-h.264-quantization.html" class="sidebar-link">
			H.264 Quantization
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-04-06-quantization-method.html" class="sidebar-link">
			Quantization Method
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-04-26-h.264-mode-decision.html" class="sidebar-link">
			h.264 Mode Decision
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-05-17-h.264-bi-predictive-motion-searc.html" class="sidebar-link current">
			h.264 Bi-Predictive Motion Search
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-02-24-h.264%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html" class="sidebar-link">
			h.264语法结构分析
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-02-29-h.264%E5%AE%8F%E5%9D%97%E4%B8%8E%E5%AD%90%E5%AE%8F%E5%9D%97%E7%B1%BB%E5%9E%8B.html" class="sidebar-link">
			h.264宏块与子宏块类型
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-05-h.264-scanning-process-for-transform-coefficients.html" class="sidebar-link">
			h.264 scanning process for transform coefficients
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-08-cavlc.html" class="sidebar-link">
			CAVLC
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-22-cabac.html" class="sidebar-link">
			CABAC
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-25-%E7%AE%97%E6%9C%AF%E7%BC%96%E7%A0%81jm%E5%AE%9E%E7%8E%B0.html" class="sidebar-link">
			算术编码JM实现
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-04-27-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html" class="sidebar-link">
			h.264并行解码算法分析
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-05-17-h.264-%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2.html" class="sidebar-link">
			h.264 去块滤波
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-08-11-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%952d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E9%9D%9E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法2D-Wave实现（基于多核非共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-09-18-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%952d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法2D-Wave实现（基于多核共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-09-30-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%953d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法3D-Wave实现（基于多核共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2017-04-04-h.264%E5%B9%B6%E8%A1%8C%E7%86%B5%E8%A7%A3%E7%A0%81.html" class="sidebar-link">
			h.264并行熵解码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2017-06-15-cabac%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A1%A5%E5%85%85%E8%AE%A8%E8%AE%BA.html" class="sidebar-link">
			CABAC总结与补充讨论
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2019-01-04-%5Bffmpeg%5D-h264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81.html" class="sidebar-link">
			ffmpeg h264并行解码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2019-01-24-%5Bffmpeg%5D-h.264%E8%A7%A3%E7%A0%81%E6%89%80%E7%94%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%8B%E7%BB%8D.html" class="sidebar-link">
			ffmpeg h.264解码所用的主要缓冲区介绍
		  </a>
		</li>


</ul>

	  
    </div>
  </div>
</div>

<link rel="stylesheet" href="../icon/iconfont.css">
<style>

/* body {
            background: #e4e9f5;
        } */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            list-style: none;
            text-decoration: none;
        }

        section {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font: 900 100px '';
            color: #ffa21759;
            background: rgb(34, 37, 39);
        }

        .shell {
            position: fixed;
            width: 60px;
			left: 0;
            height: 100%;
            background: #000000;
            z-index: 9999;
            transition: width 0.5s;
            /* padding-left: 10px; */
            overflow: hidden;
        }
/* 悬停改变宽度 */
        .shell:hover {
            width: 300px;
        }

        .imageBox {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            overflow: hidden;
        }

        .imageBox img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .shell ul {
            position: relative;
            height: 100vh;
        }

        .shell ul li {
            position: relative;
            padding: 5px;
        }

        .active {
            background: #e4e9f5;
            border-top-left-radius: 50px;
            border-bottom-left-radius: 50px;
        }

        .active::before {
            content: "";
            position: absolute;
            top: -30px;
            right: 0;
            width: 30px;
            height: 30px;
            border-bottom-right-radius: 25px;
            box-shadow: 5px 5px 0 5px #e4e9f5;
            background: transparent;
        }

        .active::after {
            content: "";
            position: absolute;
            bottom: -30px;
            right: 0;
            width: 30px;
            height: 30px;
            border-top-right-radius: 25px;
            box-shadow: 5px -5px 0 5px #e4e9f5;
            background: transparent;
        }

        #shelllogo {
            margin: 40px 0 100px 0;
        }

        .shell ul li a {
            position: relative;
            display: flex;
            white-space: nowrap;
        }

        .icon {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 40px;
            /* padding-left: 10px; */
            height: 70px;
            color: #333;
            transition: 0.5s;
            color: rgb(255, 255, 255);
        }

        .icon i {
            font-size: 30px;
            z-index: 999;
        }

        .text {
            position: relative;
            height: 70px;
            display: flex;
            align-items: center;
            font-size: 20px;
            color: #ffad32c1;
            padding-left: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.5s;
        }

        .shell ul li:hover a .icon,
        .shell ul li:hover a .text {
            color: #ffa117;
        }

        .active a .icon::before {
            content: "";
            position: absolute;
            inset: 5px;
            width: 60px;
            background: #000000;
            /* 圆形 */
            border-radius: 50%;
            transition: 0.5s;
            border: 7px solid #ffa117;
            box-sizing: border-box;
        }
</style>


<div class="shell">
	<ul class="nav">
		<li class="active" id="shelllogo">
			<a href="#">
				<div class="icon">
					<div class="imageBox">
						<img src="../icon/cat.jpg" alt="">
					</div>
				</div>
				<div class="text">前端小窝</div>
			</a>
		</li>
		<li>
			<a href="#home">
				<div class="icon">
					<i class="iconfont icon-cangku"></i>
				</div>
				<div class="text">Home</div>
			</a>
		</li>
		<li>
			<a href="#theme">
				<div class="icon">
					<!-- 调色板 -->
					<i class="iconfont icon-tiaoseban"></i>
				</div>
				<div class="text">Theme</div>
			</a>
		</li>
		<li>
			<a href="#wallet">
				<div class="icon">
					<!-- 钱包 -->
					<i class="iconfont icon-qianbao"></i>
				</div>
				<div class="text">Wallet</div>
			</a>
		</li>
		<li>
			<a href="#picture">
				<div class="icon">
					<!-- 图片 -->
					<i class="iconfont icon-tupian"></i>
				</div>
				<div class="text">picture</div>
			</a>
		</li>
		<li>
			<a href="#code">
				<div class="icon">
					<!-- 二维码 -->
					<i class="iconfont icon-erweima"></i>
				</div>
				<div class="text">QR code</div>
			</a>
		</li>
		<li>
			<a href="#authentication">
				<div class="icon">
					<!-- 盾牌保险认证 -->
					<i class="iconfont icon-dunpaibaoxianrenzheng"></i>
				</div>
				<div class="text">auth</div>
			</a>
		</li>
		<li>
			<a href="#me">
				<div class="icon">
					<div class="imageBox">
						<img src="./cat.jpg" alt="">
					</div>
				</div>
				<div class="text">ME</div>
			</a>
		</li>
	</ul>
</div>

<div class="content book-zh-cn with-sidebar 2015-05-17-h.264-bi-predictive-motion-searc-guide">
  <p>在做B帧的运动预测时，有两组参考图像列表（refList0, refList1），需要进行分别前向预测、后向预测。传统的预测方式是：</p>
<ol>
<li><p>对refList0进行前向预测，得到最佳前向ref与mv。</p>
</li>
<li><p>对refList1进行后向预测，得到最佳后向ref与mv。</p>
</li>
<li><p>对比三组ref与mv（前向、后向、前向+后向），从中选择最佳的ref与mv。</p>
</li>
</ol>
<p>如果最终得到的是前向+后向的方式，那这就是典型的B帧预测方式。不过这种方式会存在以下的问题：</p>
<ol>
<li><p>refList0,refList1的最佳ref与mv是分开进行预测的，即在计算cost时，预测块取值采用的是单独的前向预测块与单独的后向预测块。</p>
</li>
<li><p>对比三组ref与mv时，预测块取值为前向预测块与后向预测块之和的一半。</p>
</li>
<li><p>在进行残差编码时，预测块取值为前向预测块与后向预测块之和的一半。</p>
</li>
</ol>
<img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172057440732449.jpg">

<p>可以看到在运动预测时，预测块的取值方式与最后的残差编码的取值方式不同，那么这种运动预测所得到的mv能否在计算残差编码时使得残差最小？答案不能肯定，因为运动预测时的预测块值与残差编码的预测块值不是一样的。不过对于这种B帧预测的情况，肯定有更好的运动预测方式：令运动预测时的预测块的预测方式与残差编码的预测块的预测方式一致。</p>
<h1 id="Bi-predictive-motion-search"><a href="#Bi-predictive-motion-search" class="headerlink" title="Bi-predictive motion search"></a>Bi-predictive motion search</h1><p>双向预测运动搜索（Bi-predictive motion search）相对于上述传统类型的运动预测方式，主要的改进是在计算cost时，预测块的取值为前向预测块与后向预测块的一半。</p>
<img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172057455735707.jpg">
这种运动估计方式，既保持了运动估计与残差编码的一致性，又充分考虑到了前后参考图像的耦合性。
在传统的运动估计中，由于前、后向估计是分开的，但是在残差编码时需要对前、后预测块进行组合，因此如果前、后参考帧关联性很强的话，这种单独的预测方式所得到的组合预测块（combination predicted block）并可能非最佳的预测块，如下图：

<p><img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172057466832380.png"><img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172057473086737.png"><br>（注：左：前后预测块的像素直方图；右：当前块的像素直方图）</p>
<p>采用双向预测运动搜索后，即使原本在单向预测时被判定为不是最佳的运动向量，如果前、后参考帧的关联性很强的话，也可能由于前后向结合搜索从而得到与当前块差距最小的组合预测块（combination predicted block）<br><img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172057481674165.png"><img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172057493708866.png"><br>（注：左：前后预测块的像素直方图；右：当前块的像素直方图）</p>
<p>JM18.6实现<br>首先，是在B slice下才会进行双向预测运动搜索。<br>既然需要对两个参考图像同时进行预测，那么这两个参考图像应该如何选择呢？在JM18.6中，只对两个参考图像列表的ref0执行这种双向预测运动搜索，并且在进行搜索时，两个参考图像都是ref0，即ref0List[0],ref1List[0]。</p>
<p>&#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Block motion search</li>
</ul>
<hr>
<p> *&#x2F;<br>distblk                                         &#x2F;&#x2F;!&lt; minimum motion cost after search<br>BlockMotionSearch (Macroblock *currMB,      &#x2F;&#x2F;!&lt; Current Macroblock<br>                   MEBlock   <em>mv_block,     &#x2F;&#x2F;!&lt; Motion estimation information block<br>                   int       mb_x,          &#x2F;&#x2F;!&lt; x-coordinate inside macroblock<br>                   int       mb_y,          &#x2F;&#x2F;!&lt; y-coordinate inside macroblock<br>                   int</em>      lambda_factor) &#x2F;&#x2F;!&lt; lagrangian parameter for determining motion cost<br>{<br>  …</p>
<p>  &#x2F;&#x2F; Bipred ME consideration: returns minimum bipred cost<br>  if (is_bipred_enabled(p_Vid, blocktype) &amp;&amp; (ref &#x3D;&#x3D; 0))<br>  {<br>    BiPredBlockMotionSearch(currMB, mv_block, &amp;pred, mb_x, mb_y, lambda_factor);<br>  }</p>
<p>  return min_mcost;<br>}</p>
<p>&#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>UMHEXBipredIntegerPelBlockMotionSearch: fast pixel block motion search for bipred mode</li>
<li>this algrithm is called UMHexagonS(see JVT-D016),which includes</li>
<li>four steps with different kinds of search patterns</li>
<li>\author</li>
<li>Main contributors: (see contributors.h for copyright, address and affiliation details)</li>
<li><ul>
<li>Zhibo Chen         <a href="mailto:&#x63;&#104;&#x65;&#x6e;&#x7a;&#104;&#x69;&#98;&#x6f;&#64;&#116;&#x73;&#105;&#110;&#x67;&#x68;&#x75;&#x61;&#46;&#x6f;&#114;&#103;&#x2e;&#99;&#110;">&#x63;&#104;&#x65;&#x6e;&#x7a;&#104;&#x69;&#98;&#x6f;&#64;&#116;&#x73;&#105;&#110;&#x67;&#x68;&#x75;&#x61;&#46;&#x6f;&#114;&#103;&#x2e;&#99;&#110;</a></li>
</ul>
</li>
<li><ul>
<li>JianFeng Xu        <a href="mailto:&#102;&#x65;&#110;&#x61;&#120;&#x40;&#118;&#105;&#100;&#x65;&#x6f;&#46;&#109;&#100;&#x63;&#x2e;&#116;&#115;&#105;&#110;&#x67;&#104;&#x75;&#97;&#46;&#101;&#100;&#117;&#46;&#99;&#110;">&#102;&#x65;&#110;&#x61;&#120;&#x40;&#118;&#105;&#100;&#x65;&#x6f;&#46;&#109;&#100;&#x63;&#x2e;&#116;&#115;&#105;&#110;&#x67;&#104;&#x75;&#97;&#46;&#101;&#100;&#117;&#46;&#99;&#110;</a></li>
</ul>
</li>
<li><ul>
<li>Xiaozhong Xu       <a href="mailto:&#x78;&#120;&#122;&#64;&#x76;&#105;&#100;&#101;&#111;&#x2e;&#x6d;&#100;&#99;&#x2e;&#116;&#x73;&#x69;&#110;&#x67;&#x68;&#117;&#97;&#x2e;&#x65;&#100;&#117;&#x2e;&#x63;&#x6e;">&#x78;&#120;&#122;&#64;&#x76;&#105;&#100;&#101;&#111;&#x2e;&#x6d;&#100;&#99;&#x2e;&#116;&#x73;&#x69;&#110;&#x67;&#x68;&#117;&#97;&#x2e;&#x65;&#100;&#117;&#x2e;&#x63;&#x6e;</a></li>
</ul>
</li>
<li>\date   :</li>
<li>2006.1</li>
</ul>
<hr>
<p>*&#x2F;<br>distblk                                                &#x2F;&#x2F;  &#x3D;&#x3D;&gt; minimum motion cost after search<br>UMHEXBipredIntegerPelBlockMotionSearch (Macroblock *currMB,      &#x2F;&#x2F; &lt;–  current Macroblock<br>                                        int       list,          &#x2F;&#x2F; &lt;–  current reference list<br>                                        MotionVector *pred_mv1,  &#x2F;&#x2F; &lt;–  motion vector predictor (x|y) in sub-pel units<br>                                        MotionVector *pred_mv2,  &#x2F;&#x2F; &lt;–  motion vector predictor (x|y) in sub-pel units<br>                                        MotionVector  *mv1,      &#x2F;&#x2F; &lt;–&gt; in: search center (x|y) &#x2F; out: motion vector (x|y) - in sub-pel units<br>                                        MotionVector *mv2,       &#x2F;&#x2F; &lt;–&gt; in: search center (x|y)<br>                                        MEBlock *mv_block,       &#x2F;&#x2F; &lt;–  motion vector information<br>                                        int       search_range,  &#x2F;&#x2F; &lt;–  1-d search range in sub-pel units<br>                                        distblk       min_mcost,     &#x2F;&#x2F; &lt;–  minimum motion cost (cost for center or huge value)<br>                                        int       lambda_factor  &#x2F;&#x2F; &lt;–  lagrangian parameter for determining motion cost<br>                                        )<br>{<br>  …<br>  &#x2F;&#x2F;maybe wrong,should swap ref1 and ref2 ,not listX[list][ref] and listX[list][0]<br>  &#x2F;&#x2F;ok, only ref &#x3D;&#x3D; 0 comes into this function<br>  StorablePicture *ref_picture1 &#x3D; currSlice-&gt;listX[list + currMB-&gt;list_offset][ref];<br>  StorablePicture *ref_picture2 &#x3D; currSlice-&gt;listX[list &#x3D;&#x3D; 0 ? 1 + currMB-&gt;list_offset: currMB-&gt;list_offset][ 0 ];</p>
<p>  …<br>}</p>
<p>由于有两个参考图像，但是在进行一次运动搜索时，不可能对两个参考图像同时进行搜索，因此轮询对两张参考图像进行搜索。流程如下：</p>
<ol>
<li><p>假设当前参考图像为ref0List[0]，那么令ref0List[0]（前向）由单向运动搜索已经得到的mv作为该参考图像的候选mv，并且在此次搜索过程中保持不变。</p>
</li>
<li><p>Ref1List[0]为本次搜索过程的搜索对象。先求出后向mvp，用于运动搜索。</p>
</li>
<li><p>采用某种算法（如：UMH）进行运动搜索，与普通的运动搜索的不同只有在计算cost时同时用了ref0List[0]的候选mv与ref1List[0]的候选mv。</p>
</li>
<li><p>得到此次运动搜索的ref1List[0]的最佳mv后，保存起来，交换ref0List[0]与ref1List[1]，刚刚得到的最佳mv为下一次运动搜索的固定mv。</p>
</li>
<li><p>3与4轮询几次后即可得到最终结果。</p>
</li>
</ol>
<img alt="" src="img/2015-05-17-h.264-bi-predictive-motion-search/172121228874003.jpg">


<p>&#x2F;*!</p>
<hr>
<ul>
<li>\brief</li>
<li>Bi-predictive motion search</li>
</ul>
<hr>
<p> *&#x2F;<br>static distblk BiPredBlockMotionSearch(Macroblock   *currMB,      &#x2F;&#x2F;!&lt; Current Macroblock<br>                                       MEBlock      *mv_block,<br>                                       MotionVector *pred_mv,     &#x2F;&#x2F;!&lt; current list motion vector predictor<br>                                       int           mb_x,            &#x2F;&#x2F;!&lt; x-coordinate inside macroblock<br>                                       int           mb_y,            &#x2F;&#x2F;!&lt; y-coordinate inside macroblock<br>                                       int*          lambda_factor)   &#x2F;&#x2F;!&lt; lagrangian parameter for determining motion cost<br>{<br>  VideoParameters *p_Vid     &#x3D; currMB-&gt;p_Vid;<br>  InputParameters *p_Inp     &#x3D; currMB-&gt;p_Inp;<br>  Slice           *currSlice &#x3D; currMB-&gt;p_Slice;<br>  int         list &#x3D; mv_block-&gt;list;<br>  int         i, j;<br>  short       bipred_type &#x3D; list ? 0 : 1;<br>  MotionVector ***** bipred_mv &#x3D; currSlice-&gt;bipred_mv[bipred_type];<br>  distblk     min_mcostbi &#x3D; DISTBLK_MAX;<br>  MotionVector *mv &#x3D; &amp;mv_block-&gt;mv[list];         &#x2F;&#x2F;1.用从单向运动搜索得到的mv作为候选mv<br>  MotionVector bimv, tempmv;<br>  MotionVector pred_mv1, pred_mv2, pred_bi;<br>  MotionVector *bi_mv1 &#x3D; NULL, *bi_mv2 &#x3D; NULL;<br>  short       iterlist &#x3D; (short) list;<br>  int         block_x   &#x3D; (mb_x&gt;&gt;2);<br>  int         block_y   &#x3D; (mb_y&gt;&gt;2);<br>  int         blocktype &#x3D; mv_block-&gt;blocktype;<br>  int         bsx       &#x3D; mv_block-&gt;blocksize_x;<br>  int         bsy       &#x3D; mv_block-&gt;blocksize_y;<br>  &#x2F;&#x2F;PixelPos    block[4];  &#x2F;&#x2F; neighbor blocks</p>
<p>  &#x2F;&#x2F;get_neighbors(currMB, mv_block-&gt;block, mb_x, mb_y, bsx);</p>
<p>  if (p_Inp-&gt;SearchMode[p_Vid-&gt;view_id] &#x3D;&#x3D; UM_HEX)<br>  {<br>    p_Vid-&gt;p_UMHex-&gt;bipred_flag &#x3D; 1;<br>    &#x2F;&#x2F;2.求出后（前）向mvp<br>    UMHEXSetMotionVectorPredictor(currMB, &amp;pred_bi, p_Vid-&gt;enc_picture-&gt;mv_info, 0, list ^ 1, mb_x, mb_y, bsx, bsy, mv_block);<br>  }<br>  else<br>    currMB-&gt;GetMVPredictor (currMB, mv_block-&gt;block, &amp;pred_bi, 0, p_Vid-&gt;enc_picture-&gt;mv_info, list ^ 1, mb_x, mb_y, bsx, bsy);</p>
<p>  if ((p_Inp-&gt;SearchMode[p_Vid-&gt;view_id] !&#x3D; EPZS) || (p_Inp-&gt;EPZSSubPelGrid &#x3D;&#x3D; 0))<br>  {<br>    mv-&gt;mv_x &#x3D; ((mv-&gt;mv_x  + 2) &gt;&gt; 2) * 4;<br>    mv-&gt;mv_y &#x3D; ((mv-&gt;mv_y  + 2) &gt;&gt; 2) * 4;<br>    bimv.mv_x &#x3D; ((pred_bi.mv_x  + 2) &gt;&gt; 2) * 4;<br>    bimv.mv_y &#x3D; ((pred_bi.mv_y  + 2) &gt;&gt; 2) * 4;<br>  }<br>  else<br>  {<br>    bimv &#x3D; pred_bi;<br>  }</p>
<p>  &#x2F;&#x2F;Bi-predictive motion Refinements<br>  for (mv_block-&gt;iteration_no &#x3D; 0; mv_block-&gt;iteration_no &lt;&#x3D; p_Inp-&gt;BiPredMERefinements; mv_block-&gt;iteration_no++)<br>  {<br>    if (mv_block-&gt;iteration_no &amp; 0x01)           &#x2F;&#x2F;4.参考图像交换<br>    {<br>      pred_mv1  &#x3D; *pred_mv;<br>      pred_mv2  &#x3D; pred_bi;<br>      bi_mv1    &#x3D; mv;<br>      bi_mv2    &#x3D; &bimv;<br>      iterlist  &#x3D; (short) list;<br>    }<br>    else<br>    {<br>      pred_mv1  &#x3D; pred_bi;<br>      pred_mv2  &#x3D; *pred_mv;<br>      bi_mv1    &#x3D; &bimv;<br>      bi_mv2    &#x3D; mv;<br>      iterlist &#x3D; (short) (list ^ 1);<br>    }</p>
<pre><code>tempmv = *bi_mv1;

PrepareBiPredMEParams(currSlice, mv_block, mv_block-&gt;ChromaMEEnable, iterlist, currMB-&gt;list_offset, mv_block-&gt;ref_idx);
// Get bipred mvs for list iterlist given previously computed mvs from other list
min_mcostbi = currMB-&gt;BiPredME (currMB, iterlist, 
  &amp;pred_mv1, &amp;pred_mv2, bi_mv1, bi_mv2, mv_block, 
  (p_Inp-&gt;BiPredMESearchRange[p_Vid-&gt;view_id] &lt;&lt;2)&gt;&gt;mv_block-&gt;iteration_no, min_mcostbi, lambda_factor[F_PEL]);

if (mv_block-&gt;iteration_no &gt; 0 &amp;&amp; (tempmv.mv_x == bi_mv1-&gt;mv_x) &amp;&amp; (tempmv.mv_y == bi_mv1-&gt;mv_y))
&#123;
  break;
&#125;
</code></pre>
<p>  }</p>
<p>  if (!p_Inp-&gt;DisableSubpelME[p_Vid-&gt;view_id])<br>  {<br>    if (p_Inp-&gt;BiPredMESubPel)<br>    {<br>      if ( !p_Vid-&gt;start_me_refinement_hp )<br>        min_mcostbi &#x3D; DISTBLK_MAX;<br>      PrepareBiPredMEParams(currSlice, mv_block, mv_block-&gt;ChromaMEEnable, iterlist, currMB-&gt;list_offset, mv_block-&gt;ref_idx);</p>
<pre><code>  min_mcostbi =  currMB-&gt;SubPelBiPredME (currMB, mv_block, iterlist, &amp;pred_mv1, &amp;pred_mv2, bi_mv1, bi_mv2, min_mcostbi, lambda_factor);
&#125;

if (p_Inp-&gt;BiPredMESubPel==2)
&#123;
  if ( !p_Vid-&gt;start_me_refinement_qp )
    min_mcostbi = DISTBLK_MAX;
  PrepareBiPredMEParams(currSlice, mv_block, mv_block-&gt;ChromaMEEnable, iterlist ^ 1, currMB-&gt;list_offset, mv_block-&gt;ref_idx);

  min_mcostbi =  currMB-&gt;SubPelBiPredME (currMB, mv_block, iterlist ^ 1, &amp;pred_mv2, &amp;pred_mv1, bi_mv2, bi_mv1, min_mcostbi, lambda_factor);
&#125;
</code></pre>
<p>  }</p>
<p>  clip_mv_range(p_Vid, 0, bi_mv1, Q_PEL);<br>  clip_mv_range(p_Vid, 0, bi_mv2, Q_PEL);</p>
<p>  for (j&#x3D;block_y; j &lt; block_y + (bsy&gt;&gt;2); j++)<br>  {<br>    for (i&#x3D;block_x ; i &lt; block_x + (bsx&gt;&gt;2); i++)<br>    {<br>      bipred_mv[iterlist    ][(short) mv_block-&gt;ref_idx][blocktype][j][i] &#x3D; *bi_mv1;<br>      bipred_mv[iterlist ^ 1][(short) mv_block-&gt;ref_idx][blocktype][j][i] &#x3D; *bi_mv2;<br>    }<br>  }</p>
<p>  return min_mcostbi;<br>}</p>
<p>#define SEARCH_ONE_PIXEL_BIPRED                                                                         <br>if((iabs(cand.mv_x - center2.mv_x) &gt;&gt; 2) &lt; search_range &amp;&amp; (iabs(cand.mv_y - center2.mv_y) &gt;&gt; 2) &lt; search_range)     <br>{                                                                                                       <br>  if(!p_UMHex-&gt;McostState[((cand.mv_y - center2.mv_y) &gt;&gt; 2) + search_range][((cand.mv_x-center2.mv_x) &gt;&gt; 2)+search_range])         <br>  {                                                                                                     <br>    mcost  &#x3D; mv_cost (p_Vid, lambda_factor, &amp;center1, &amp;pred1);                                          <br>    mcost +&#x3D; mv_cost (p_Vid, lambda_factor, &amp;cand, &amp;pred2);                                             <br>    if(mcost&lt;min_mcost)                                                                                   <br>    {                                                                                                     <br>      mcost  +&#x3D; mv_block-&gt;computeBiPredFPel(ref_picture1, ref_picture2,                                 \ &#x2F;&#x2F;3.组合两个ref来进行cost计算<br>      mv_block, min_mcost - mcost, &amp;center1, &amp;cand);                                                <br>      p_UMHex-&gt;McostState[((cand.mv_y - center2.mv_y) &gt;&gt; 2) + search_range][((cand.mv_x - center2.mv_x) &gt;&gt; 2) + search_range] &#x3D; 1; <br>      if (mcost &lt; min_mcost)                                                                            <br>      {                                                                                                 <br>        best &#x3D; cand;                                                                                    <br>        min_mcost &#x3D; mcost;                                                                              <br>      }                                                                                                 <br>    }                                                                                                   <br>  }                                                                                                     <br>}</p>
<p>在JM18.6中，采用这种运动搜索方式需要满足以下几种条件：1. Bslice, 2. 输入参数指定了BiPredMotionEstimation, 3. 分割模式被指定了bipred_enabled, 4. Ref &#x3D; 0。</p>

  <div class="guide-links">
    
    
  </div>

    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">欧长坤</a> &copy; 2016-2025 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>



</div>

	</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
