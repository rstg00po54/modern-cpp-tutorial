


<!DOCTYPE html>
<html lang="en">
  <head>
    <title>UMHexagonS搜索过程 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-zh-cn"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->

		<!-- mobile-bar 2-->
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>

	<!-- include header -->
    <div id="header">
  <a id="logo" href="/">
      <img src="/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>


<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/rstg00po54/modern-cpp-tutorial">GitHub</a>
</li>


  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
		<!-- body 111 -->
        



  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
        <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>


<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/rstg00po54/modern-cpp-tutorial">GitHub</a>
</li>


    </ul>
    <div class="list">
      <h2>
		
          正文

      </h2>
      <ul class="menu-root">
	  <!-- 引入外部的 JS 文件 -->
  <!-- <script src="/modern-cpp/js/menu.js"></script> -->


	<!-- 传递数据到 JavaScript -->
	
	
	

	
		<li>
		  <a href="/H264-BKY/2014-02-15-h.264%E7%9A%84poc%E8%AE%A1%E7%AE%97.html" class="sidebar-link">
			h.264的POC计算
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-02-27-%E6%8C%87%E6%95%B0%E5%93%A5%E4%BC%A6%E5%B8%83%E7%BC%96%E7%A0%81.html" class="sidebar-link">
			指数哥伦布编码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-15-h.264%E5%8A%A0%E6%9D%83%E9%A2%84%E6%B5%8B.html" class="sidebar-link">
			h.264加权预测
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-11-h.264%E7%A0%81%E7%8E%87%E6%8E%A7%E5%88%B6.html" class="sidebar-link">
			h.264码率控制
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-04-23-h.264%E7%9B%B4%E6%8E%A5%E9%A2%84%E6%B5%8B.html" class="sidebar-link">
			h.264直接预测
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-03-17-h.264-fmo.html" class="sidebar-link">
			h.264 FMO
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-05-11-h.264%E5%8F%82%E8%80%83%E5%9B%BE%E5%83%8F%E5%88%97%E8%A1%A8%E3%80%81%E8%A7%A3%E7%A0%81%E5%9B%BE%E5%83%8F%E7%BC%93%E5%AD%98.html" class="sidebar-link">
			h.264参考图像列表、解码图像缓存
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-06-h.264-mvp%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			h.264 mvp求解过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-16-umhexagons%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html" class="sidebar-link current">
			UMHexagonS搜索过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-07-20-h.264%E5%85%A8%E6%90%9C%E7%B4%A2%E4%BB%A5%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%85%A8%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html" class="sidebar-link">
			h.264全搜索以及快速全搜索算法
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-06-18-h.264-%E7%8E%87%E5%A4%B1%E7%9C%9F%E4%BC%98%E5%8C%96.html" class="sidebar-link">
			h.264 率失真优化
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-10-17-epzs%E6%90%9C%E7%B4%A2%E8%BF%87%E7%A8%8B.html" class="sidebar-link">
			EPZS搜索过程
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-12-07-intra-chroma-prediction.html" class="sidebar-link">
			Intra Chroma Prediction
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2014-12-28-intra-luma-prediction.html" class="sidebar-link">
			Intra Luma Prediction
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-01-13-h.264-transfor.html" class="sidebar-link">
			H.264 Transform
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-02-02-h.264-quantization.html" class="sidebar-link">
			H.264 Quantization
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-04-06-quantization-method.html" class="sidebar-link">
			Quantization Method
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-04-26-h.264-mode-decision.html" class="sidebar-link">
			h.264 Mode Decision
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2015-05-17-h.264-bi-predictive-motion-searc.html" class="sidebar-link">
			h.264 Bi-Predictive Motion Search
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-02-24-h.264%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html" class="sidebar-link">
			h.264语法结构分析
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-02-29-h.264%E5%AE%8F%E5%9D%97%E4%B8%8E%E5%AD%90%E5%AE%8F%E5%9D%97%E7%B1%BB%E5%9E%8B.html" class="sidebar-link">
			h.264宏块与子宏块类型
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-05-h.264-scanning-process-for-transform-coefficients.html" class="sidebar-link">
			h.264 scanning process for transform coefficients
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-08-cavlc.html" class="sidebar-link">
			CAVLC
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-22-cabac.html" class="sidebar-link">
			CABAC
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-03-25-%E7%AE%97%E6%9C%AF%E7%BC%96%E7%A0%81jm%E5%AE%9E%E7%8E%B0.html" class="sidebar-link">
			算术编码JM实现
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-04-27-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.html" class="sidebar-link">
			h.264并行解码算法分析
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-05-17-h.264-%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2.html" class="sidebar-link">
			h.264 去块滤波
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-08-11-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%952d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E9%9D%9E%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法2D-Wave实现（基于多核非共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-09-18-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%952d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法2D-Wave实现（基于多核共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2016-09-30-h.264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81%E7%AE%97%E6%B3%953d-wave%E5%AE%9E%E7%8E%B0(%E5%9F%BA%E4%BA%8E%E5%A4%9A%E6%A0%B8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F).html" class="sidebar-link">
			h.264并行解码算法3D-Wave实现（基于多核共享内存系统）
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2017-04-04-h.264%E5%B9%B6%E8%A1%8C%E7%86%B5%E8%A7%A3%E7%A0%81.html" class="sidebar-link">
			h.264并行熵解码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2017-06-15-cabac%E6%80%BB%E7%BB%93%E4%B8%8E%E8%A1%A5%E5%85%85%E8%AE%A8%E8%AE%BA.html" class="sidebar-link">
			CABAC总结与补充讨论
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2019-01-04-%5Bffmpeg%5D-h264%E5%B9%B6%E8%A1%8C%E8%A7%A3%E7%A0%81.html" class="sidebar-link">
			ffmpeg h264并行解码
		  </a>
		</li>

		<li>
		  <a href="/H264-BKY/2019-01-24-%5Bffmpeg%5D-h.264%E8%A7%A3%E7%A0%81%E6%89%80%E7%94%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BC%93%E5%86%B2%E5%8C%BA%E4%BB%8B%E7%BB%8D.html" class="sidebar-link">
			ffmpeg h.264解码所用的主要缓冲区介绍
		  </a>
		</li>


</ul>

	  
    </div>
  </div>
</div>

<link rel="stylesheet" href="../icon/iconfont.css">
<style>

/* body {
            background: #e4e9f5;
        } */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            list-style: none;
            text-decoration: none;
        }

        section {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font: 900 100px '';
            color: #ffa21759;
            background: rgb(34, 37, 39);
        }

        .shell {
            position: fixed;
            width: 60px;
			left: 0;
            height: 100%;
            background: #000000;
            z-index: 9999;
            transition: width 0.5s;
            /* padding-left: 10px; */
            overflow: hidden;
        }
/* 悬停改变宽度 */
        .shell:hover {
            width: 300px;
        }

        .imageBox {
            position: relative;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            overflow: hidden;
        }

        .imageBox img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .shell ul {
            position: relative;
            height: 100vh;
        }

        .shell ul li {
            position: relative;
            padding: 5px;
        }

        .active {
            background: #e4e9f5;
            border-top-left-radius: 50px;
            border-bottom-left-radius: 50px;
        }

        .active::before {
            content: "";
            position: absolute;
            top: -30px;
            right: 0;
            width: 30px;
            height: 30px;
            border-bottom-right-radius: 25px;
            box-shadow: 5px 5px 0 5px #e4e9f5;
            background: transparent;
        }

        .active::after {
            content: "";
            position: absolute;
            bottom: -30px;
            right: 0;
            width: 30px;
            height: 30px;
            border-top-right-radius: 25px;
            box-shadow: 5px -5px 0 5px #e4e9f5;
            background: transparent;
        }

        #shelllogo {
            margin: 40px 0 100px 0;
        }

        .shell ul li a {
            position: relative;
            display: flex;
            white-space: nowrap;
        }

        .icon {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            min-width: 40px;
            /* padding-left: 10px; */
            height: 70px;
            color: #333;
            transition: 0.5s;
            color: rgb(255, 255, 255);
        }

        .icon i {
            font-size: 30px;
            z-index: 999;
        }

        .text {
            position: relative;
            height: 70px;
            display: flex;
            align-items: center;
            font-size: 20px;
            color: #ffad32c1;
            padding-left: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: 0.5s;
        }

        .shell ul li:hover a .icon,
        .shell ul li:hover a .text {
            color: #ffa117;
        }

        .active a .icon::before {
            content: "";
            position: absolute;
            inset: 5px;
            width: 60px;
            background: #000000;
            /* 圆形 */
            border-radius: 50%;
            transition: 0.5s;
            border: 7px solid #ffa117;
            box-sizing: border-box;
        }
</style>


<div class="shell">
	<ul class="nav">
		<li class="active" id="shelllogo">
			<a href="#">
				<div class="icon">
					<div class="imageBox">
						<img src="../icon/cat.jpg" alt="">
					</div>
				</div>
				<div class="text">前端小窝</div>
			</a>
		</li>
		<li>
			<a href="#home">
				<div class="icon">
					<i class="iconfont icon-cangku"></i>
				</div>
				<div class="text">Home</div>
			</a>
		</li>
		<li>
			<a href="#theme">
				<div class="icon">
					<!-- 调色板 -->
					<i class="iconfont icon-tiaoseban"></i>
				</div>
				<div class="text">Theme</div>
			</a>
		</li>
		<li>
			<a href="#wallet">
				<div class="icon">
					<!-- 钱包 -->
					<i class="iconfont icon-qianbao"></i>
				</div>
				<div class="text">Wallet</div>
			</a>
		</li>
		<li>
			<a href="#picture">
				<div class="icon">
					<!-- 图片 -->
					<i class="iconfont icon-tupian"></i>
				</div>
				<div class="text">picture</div>
			</a>
		</li>
		<li>
			<a href="#code">
				<div class="icon">
					<!-- 二维码 -->
					<i class="iconfont icon-erweima"></i>
				</div>
				<div class="text">QR code</div>
			</a>
		</li>
		<li>
			<a href="#authentication">
				<div class="icon">
					<!-- 盾牌保险认证 -->
					<i class="iconfont icon-dunpaibaoxianrenzheng"></i>
				</div>
				<div class="text">auth</div>
			</a>
		</li>
		<li>
			<a href="#me">
				<div class="icon">
					<div class="imageBox">
						<img src="./cat.jpg" alt="">
					</div>
				</div>
				<div class="text">ME</div>
			</a>
		</li>
	</ul>
</div>

<div class="content book-zh-cn with-sidebar 2014-06-16-umhexagons搜索过程-guide">
  <p>通过相邻块的预测得到mvp后，会以mvp为基础搜索最佳的匹配块，UMHexagonS就是h.264中用的一种搜索算法。<br>UMHexagonS是一种整像素搜索算法，也就是搜索过程中，参考图像一直都是原来的重构图像，并没有使用经过插值的图像进行搜索。</p>
<p>首先UMHexagonS会根据相关信息去得到比较有可能的mv，（然后用小菱形搜索到该区域去搜索该区域中的最佳mv，这种情况会在下面注明，至于如何才算最佳，请参照<a target="_blank" rel="noopener" href="http://www.cnblogs.com/TaigaCon/p/3790218.html%EF%BC%89">http://www.cnblogs.com/TaigaCon/p/3790218.html）</a><br>由于UMHexagonS是一种整像素搜索算法，所以会存在对分数的mv取整的情况，此时取整是指把mv对齐到某个像素上，消去分数部分</p>
<h4 id="首先需要选取合适的搜索起点，有以下几种起点的选择"><a href="#首先需要选取合适的搜索起点，有以下几种起点的选择" class="headerlink" title="首先需要选取合适的搜索起点，有以下几种起点的选择"></a>首先需要选取合适的搜索起点，有以下几种起点的选择</h4><h5 id="1-mvp"><a href="#1-mvp" class="headerlink" title="1.mvp"></a>1.mvp</h5><p>由于还是整像素搜索，所以这里需要对mvp取整，得到的整数的mv后采用小菱形搜索以得到比较优秀的mv。<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/151414247496323.jpg"></p>
<h5 id="2-原点"><a href="#2-原点" class="headerlink" title="2.原点"></a>2.原点</h5><p>原点，即mv为0，即当前块的位置（然后采用小菱形搜索）<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/142242073112923.jpg"></p>
<h5 id="3-上层块mv"><a href="#3-上层块mv" class="headerlink" title="3.上层块mv"></a>3.上层块mv</h5><p>参考下图，如果当前块为8x8，那么覆盖当前块的16x8块就是其上层块<br>运动搜索中，分块模式有7种<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/142256003119341.jpg"></p>
<p>模式4的上层模式为2，模式7的上层模式为4<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/142333140306188.jpg"></p>
<h5 id="4-共同位置块mv，取上一参考图像与当前块相同位置的块的mv-然后取整"><a href="#4-共同位置块mv，取上一参考图像与当前块相同位置的块的mv-然后取整" class="headerlink" title="4.共同位置块mv，取上一参考图像与当前块相同位置的块的mv,然后取整"></a>4.共同位置块mv，取上一参考图像与当前块相同位置的块的mv,然后取整</h5><img alt="" src="img/2014-06-16-umhexagons搜索过程/151417225777684.jpg">


<h5 id="5-共同位置参考mv通过参考图像距离计算后得到的mv，然后取整"><a href="#5-共同位置参考mv通过参考图像距离计算后得到的mv，然后取整" class="headerlink" title="5.共同位置参考mv通过参考图像距离计算后得到的mv，然后取整"></a>5.共同位置参考mv通过参考图像距离计算后得到的mv，然后取整</h5><img alt="" src="img/2014-06-16-umhexagons搜索过程/151419416558874.jpg">


<h5 id="6-最后还采用一次小菱形搜索"><a href="#6-最后还采用一次小菱形搜索" class="headerlink" title="6.最后还采用一次小菱形搜索"></a>6.最后还采用一次小菱形搜索</h5><p>这里的小菱形搜索主要为了对上面3、4、5预测后得到的最佳mv再采用一次小菱形搜索以得到该区域内最佳mv<br>小菱形搜索就是把mv的x,y分别+1，-1后得到的新mv，然后各自对比得到其中最优的mv<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/151436277954122.jpg"></p>
<h4 id="Early-Termination"><a href="#Early-Termination" class="headerlink" title="Early Termination"></a>Early Termination</h4><p>通过上面的步骤得到最优的搜索起点后，需要计算该mv的匹配满意程度，以跳转做不同的后续搜索处理，该过程叫Early Termination。<br>Early Termination由于涉及到数学上的分析，所以会在后面的章节再细述。<br>Early Termination有两个个跳转出口，分别代表不同的匹配满意程度：</p>
<ul>
<li>Extended Hexagon-based Search（六边形模板反复搜索）               满意</li>
<li>the third step with a small search pattern（小菱形模板反复搜索）   很满意<br>但是如果在不甚满意的情况下，Early Termination会不作跳转，直接执行下一步</li>
</ul>
<h4 id="UMH搜索"><a href="#UMH搜索" class="headerlink" title="UMH搜索"></a>UMH搜索</h4><p>经过上面步骤后，得到其中最佳的搜索起点的mv，如果该mv经Early Termination判断为不甚满意，会以该mv为中心，直接开始UMH搜索。UMH搜索有以下步骤</p>
<h5 id="1-Unsymmetrical-cross-search（非对称十字搜索）"><a href="#1-Unsymmetrical-cross-search（非对称十字搜索）" class="headerlink" title="1.Unsymmetrical-cross search（非对称十字搜索）"></a>1.Unsymmetrical-cross search（非对称十字搜索）</h5><p>非对称十字搜索会先后对x轴与y轴进行搜索，y轴的搜索范围是x轴的一半，这是因为在一般的视频中，镜头的纵向移动距离会比较短，横向移动距离会比较长，而且比较常见。搜索时，横轴的搜索范围是search range，而纵轴会是它的一般。<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/151540599838531.jpg"></p>
<h5 id="2-Spiral-search（螺旋搜索）"><a href="#2-Spiral-search（螺旋搜索）" class="headerlink" title="2.Spiral search（螺旋搜索）"></a>2.Spiral search（螺旋搜索）</h5><p>螺旋搜索采用的是full search（全搜索）的搜索方法，但是搜索步长只有24，相当于5x5的区域。而全搜索会对整个搜索范围进行搜索。<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/152255222175756.jpg"></p>
<h5 id="3-Uneven-Multi-Hexagon-grid-Search（不规律六边形模板搜索）"><a href="#3-Uneven-Multi-Hexagon-grid-Search（不规律六边形模板搜索）" class="headerlink" title="3.Uneven Multi-Hexagon-grid Search（不规律六边形模板搜索）"></a>3.Uneven Multi-Hexagon-grid Search（不规律六边形模板搜索）</h5><p>这种搜索方式是以当前mv指向的像素点为圆心，一圈一圈地往外搜索，一旦在某个圈内搜索到更佳的位置，立刻停止搜索，否则搜索完整个搜索范围<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/152312271247204.jpg"></p>
<h5 id="4-Extended-Hexagon-based-Search（六边形模板反复搜索）"><a href="#4-Extended-Hexagon-based-Search（六边形模板反复搜索）" class="headerlink" title="4.Extended Hexagon-based Search（六边形模板反复搜索）"></a>4.Extended Hexagon-based Search（六边形模板反复搜索）</h5><p>不同于上一个搜索方式，这种搜索方式是以当前最佳mv指向的像素点为圆心，进行一次六边形模板搜索，一旦搜索到某个更佳的位置，则以此位置为圆心，重新进行一次六边形模板搜索。如果没有比圆心更佳的位置，则终止搜索。<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/152336506707192.jpg"></p>
<h5 id="5-the-third-step-with-a-small-search-pattern（小菱形模板反复搜索）"><a href="#5-the-third-step-with-a-small-search-pattern（小菱形模板反复搜索）" class="headerlink" title="5.the third step with a small search pattern（小菱形模板反复搜索）"></a>5.the third step with a small search pattern（小菱形模板反复搜索）</h5><p>类似Extended Hexagon-based Search（六边形模板反复搜索）的搜索方式，不过把六边形换成了菱形<br><img alt="" src="img/2014-06-16-umhexagons搜索过程/152358311242089.jpg"></p>
<p>以上可参照jvt-G016<br>JM8.6<br>&#x2F;*!</p>
<hr>
<ul>
<li>\brief用非对称十字形多层次六边形格点搜索算法进行运动搜索</li>
<li>FastIntegerPelBlockMotionSearch: fast pixel block motion search </li>
<li>this algrithm is called UMHexagonS(see JVT-D016),which includes </li>
<li>four steps with different kinds of search patterns</li>
<li>\par Input:</li>
<li>pel_t**   orig_pic,     &#x2F;&#x2F; &lt;–  original picture</li>
<li>int       ref,          &#x2F;&#x2F; &lt;–  reference frame (0… or -1 (backward))</li>
<li>int       pic_pix_x,    &#x2F;&#x2F; &lt;–  absolute x-coordinate of regarded AxB block</li>
<li>int       pic_pix_y,    &#x2F;&#x2F; &lt;–  absolute y-coordinate of regarded AxB block</li>
<li>int       blocktype,    &#x2F;&#x2F; &lt;–  block type (1-16x16 … 7-4x4)</li>
<li>int       pred_mv_x,    &#x2F;&#x2F; &lt;–  motion vector predictor (x) in sub-pel units</li>
<li>int       pred_mv_y,    &#x2F;&#x2F; &lt;–  motion vector predictor (y) in sub-pel units</li>
<li>int*      mv_x,         &#x2F;&#x2F;  –&gt; motion vector (x) - in pel units</li>
<li>int*      mv_y,         &#x2F;&#x2F;  –&gt; motion vector (y) - in pel units</li>
<li>int       search_range, &#x2F;&#x2F; &lt;–  1-d search range in pel units                         </li>
<li>int       min_mcost,    &#x2F;&#x2F; &lt;–  minimum motion cost (cost for center or huge value)</li>
<li>double    lambda        &#x2F;&#x2F; &lt;–  lagrangian parameter for determining motion cost</li>
<li>\par</li>
<li>Three macro definitions defined in this program:</li>
<li><ol>
<li>EARLY_TERMINATION: early termination algrithm, refer to JVT-D016.doc</li>
</ol>
</li>
<li><ol start="2">
<li>SEARCH_ONE_PIXEL: search one pixel in search range</li>
</ol>
</li>
<li><ol start="3">
<li>SEARCH_ONE_PIXEL1(value_iAbort): search one pixel in search range,</li>
</ol>
</li>
<li><pre><code>                            but give a parameter to show if mincost refeshed
</code></pre>
</li>
<li>\ Main contributors: (see contributors.h for copyright, address and affiliation details)</li>
<li>Zhibo Chen         <a href="mailto:&#99;&#x68;&#101;&#110;&#122;&#104;&#105;&#98;&#x6f;&#64;&#x74;&#115;&#x69;&#110;&#103;&#x68;&#117;&#x61;&#46;&#111;&#x72;&#x67;&#46;&#x63;&#x6e;">&#99;&#x68;&#101;&#110;&#122;&#104;&#105;&#98;&#x6f;&#64;&#x74;&#115;&#x69;&#110;&#103;&#x68;&#117;&#x61;&#46;&#111;&#x72;&#x67;&#46;&#x63;&#x6e;</a></li>
<li>JianFeng Xu        <a href="mailto:&#x66;&#101;&#x6e;&#97;&#x78;&#x40;&#x76;&#105;&#100;&#101;&#111;&#46;&#x6d;&#100;&#x63;&#x2e;&#116;&#x73;&#x69;&#x6e;&#x67;&#x68;&#x75;&#x61;&#46;&#101;&#x64;&#x75;&#x2e;&#x63;&#x6e;">&#x66;&#101;&#x6e;&#97;&#x78;&#x40;&#x76;&#105;&#100;&#101;&#111;&#46;&#x6d;&#100;&#x63;&#x2e;&#116;&#x73;&#x69;&#x6e;&#x67;&#x68;&#x75;&#x61;&#46;&#101;&#x64;&#x75;&#x2e;&#x63;&#x6e;</a>  </li>
<li>\date   : 2003.8</li>
</ul>
<hr>
<p> <em>&#x2F;<br>int                                     &#x2F;&#x2F;  &#x3D;&#x3D;&gt; minimum motion cost after search<br>FastIntegerPelBlockMotionSearch  (pel_t</em>*   orig_pic,     &#x2F;&#x2F; &lt;–  not used<br>                  int       ref,          &#x2F;&#x2F; &lt;–  reference frame (0… or -1 (backward))<br>                  int       list,<br>                  int       pic_pix_x,    &#x2F;&#x2F; &lt;–  absolute x-coordinate of regarded AxB block<br>                  int       pic_pix_y,    &#x2F;&#x2F; &lt;–  absolute y-coordinate of regarded AxB block<br>                  int       blocktype,    &#x2F;&#x2F; &lt;–  block type (1-16x16 … 7-4x4)<br>                  int       pred_mv_x,    &#x2F;&#x2F; &lt;–  motion vector predictor (x) in sub-pel units MV_pred_space 中值预测矢量<br>                  int       pred_mv_y,    &#x2F;&#x2F; &lt;–  motion vector predictor (y) in sub-pel units<br>                  int*      mv_x,         &#x2F;* –&gt; motion vector (x) - in pel units<br>                                      按照H.264标准算法进行的运动矢量预测得到MV_pred<br>                                      指的是SetMotionVectorPreditor函数预测的MV<br>                                      和中值预测的区别在于SetMotionVectorPreditor函数预测的MV的参考邻块和当前块必须参<br>                                      考同一个参考帧，而中值预测的邻块则没有这个要求，二者可能一样，也可能不同*&#x2F;<br>                  int*      mv_y,         &#x2F;&#x2F;  –&gt; motion vector (y) - in pel units<br>                  int       search_range, &#x2F;&#x2F; &lt;–  1-d search range in pel units<br>                  int       min_mcost,    &#x2F;&#x2F; &lt;–  minimum motion cost (cost for center or huge value)<br>                  double    lambda)       &#x2F;&#x2F; &lt;–  lagrangian parameter for determining motion cost<br>{<br>  static int Diamond_x[4] &#x3D; {-1, 0, 1, 0};&#x2F;&#x2F;对应不同算法  菱形插值<br>  static int Diamond_y[4] &#x3D; {0, 1, 0, -1};<br>  static int Hexagon_x[6] &#x3D; {2, 1, -1, -2, -1, 1};&#x2F;&#x2F;六角形插值<br>  static int Hexagon_y[6] &#x3D; {0, -2, -2, 0,  2, 2};<br>  static int Big_Hexagon_x[16] &#x3D; {0,-2, -4,-4,-4, -4, -4, -2,  0,  2,  4,  4, 4, 4, 4, 2};<br>  static int Big_Hexagon_y[16] &#x3D; {4, 3, 2,  1, 0, -1, -2, -3, -4, -3, -2, -1, 0, 1, 2, 3};&#x2F;&#x2F;大六角形插值</p>
<p>  int   pos, cand_x, cand_y,  mcost;<br>  pel_t <em>(<em>get_ref_line)(int, pel_t</em>, int, int, int, int);<br>  int   list_offset   &#x3D; ((img-&gt;MbaffFrameFlag)&amp;&amp;(img-&gt;mb_data[img-&gt;current_mb_nr].mb_field))? img-&gt;current_mb_nr%2 ? 4 : 2 : 0;<br>  pel_t</em>  ref_pic       &#x3D; listX[list+list_offset][ref]-&gt;imgY_11;&#x2F;&#x2F;img-&gt;type&#x3D;&#x3D;B_IMG? Refbuf11 [ref+((mref&#x3D;&#x3D;mref_fld)) +1] : Refbuf11[ref];<br>  int   best_pos      &#x3D; 0;                                        &#x2F;&#x2F; position with minimum motion cost<br>  int   max_pos       &#x3D; (2<em>search_range+1)</em>(2*search_range+1);    &#x2F;&#x2F; number of search positions<br>  int   lambda_factor &#x3D; LAMBDA_FACTOR (lambda);                   &#x2F;&#x2F; factor for determining lagragian motion cost<br>  int   mvshift       &#x3D; 2;                  &#x2F;&#x2F; motion vector shift for getting sub-pel units<br>  int   blocksize_y   &#x3D; input-&gt;blc_size[blocktype][1];            &#x2F;&#x2F; vertical block size<br>  int   blocksize_x   &#x3D; input-&gt;blc_size[blocktype][0];            &#x2F;&#x2F; horizontal block size<br>  int   blocksize_x4  &#x3D; blocksize_x &gt;&gt; 2;                         &#x2F;&#x2F; horizontal block size in 4-pel units<br>  int   pred_x        &#x3D; (pic_pix_x &lt;&lt; mvshift) + pred_mv_x;       &#x2F;&#x2F; predicted position x (in sub-pel units)<br>  int   pred_y        &#x3D; (pic_pix_y &lt;&lt; mvshift) + pred_mv_y;       &#x2F;&#x2F; predicted position y (in sub-pel units)<br>  int   center_x      &#x3D; pic_pix_x + *mv_x;                        &#x2F;&#x2F; center position x (in pel units)<br>  int   center_y      &#x3D; pic_pix_y + *mv_y;                        &#x2F;&#x2F; center position y (in pel units)<br>  int    best_x, best_y;<br>  int   check_for_00  &#x3D; (blocktype&#x3D;&#x3D;1 &amp;&amp; !input-&gt;rdopt &amp;&amp; img-&gt;type!&#x3D;B_SLICE &amp;&amp; ref&#x3D;&#x3D;0);<br>  int   search_step,iYMinNow, iXMinNow;<br>  int   i,m, iSADLayer;<br>  int   iAbort;<br>  int       N_Bframe &#x3D; input-&gt;successive_Bframe;<br>  float betaSec,betaThird;<br>  int height&#x3D;((img-&gt;MbaffFrameFlag)&amp;&amp;(img-&gt;mb_data[img-&gt;current_mb_nr].mb_field))?img-&gt;height&#x2F;2:img-&gt;height;</p>
<p>  &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; set function for getting reference picture lines &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br>  if ((center_x &gt; search_range) &amp;&amp; (center_x &lt; img-&gt;width -1-search_range-blocksize_x) &amp;&amp;<br>    (center_y &gt; search_range) &amp;&amp; (center_y &lt; height-1-search_range-blocksize_y)   )<br>  {<br>    get_ref_line &#x3D; FastLineX;<br>  }<br>  else<br>  {<br>    get_ref_line &#x3D; UMVLineX;  &#x2F;&#x2F;无运动矢量限制，需像素拓展<br>  }</p>
<p>  &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;allocate memory for search state&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;初始化搜索标记<br>  memset(McostState[0],0,(2<em>search_range+1)</em>(2*search_range+1)*4);</p>
<p>   &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Threshold defined for early termination&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;<br>  &#x2F;&#x2F;为早期终止设定门限值<br>  if(ref&gt;0)<br>  {<br>    if(pred_SAD_ref!&#x3D;0)<br>    {<br>      betaSec &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_ref<em>pred_SAD_ref)-AlphaSec[blocktype];<br>      betaThird &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_ref</em>pred_SAD_ref)-AlphaThird[blocktype];<br>    }<br>    else<br>    {<br>      betaSec &#x3D; 0;<br>      betaThird &#x3D; 0;<br>    }<br>  }<br>  else<br>  {<br>    if(blocktype&#x3D;&#x3D;1)<br>    {<br>      if(pred_SAD_space !&#x3D;0)<br>      {<br>        betaSec &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_space<em>pred_SAD_space)-AlphaSec[blocktype];<br>        betaThird &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_space</em>pred_SAD_space)-AlphaThird[blocktype];<br>      }<br>      else<br>      {<br>        betaSec &#x3D; 0;<br>        betaThird &#x3D; 0;<br>      }<br>    }<br>    else<br>    {<br>      if(pred_SAD_uplayer !&#x3D;0)<br>      {<br>        betaSec &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_uplayer<em>pred_SAD_uplayer)-AlphaSec[blocktype];<br>        betaThird &#x3D; Bsize[blocktype]&#x2F;(pred_SAD_uplayer</em>pred_SAD_uplayer)-AlphaThird[blocktype];<br>      }<br>      else<br>      {<br>        betaSec &#x3D; 0;<br>        betaThird &#x3D; 0;<br>      }<br>    }<br>  }<br>  &#x2F;<em><strong><strong><strong><strong>检测中值预测矢量</strong></strong></strong></strong></em>*****&#x2F;&#x2F;<em>其实就是把得到的mv_pred取整得到的预测矢量</em>&#x2F;<br>  &#x2F;&#x2F;  MV_pred_space 中值预测矢量<br>  &#x2F;&#x2F;check the center median predictor<br>  cand_x &#x3D; center_x ;<br>  cand_y &#x3D; center_y ;<br>  mcost &#x3D; MV_COST (lambda_factor, mvshift, cand_x, cand_y, pred_x, pred_y);&#x2F;&#x2F;通过计算候选mv所占用的bit得到mv_cost &#x3D; lambda * bit_of_mv<br>  mcost &#x3D; PartCalMad(ref_pic, orig_pic, get_ref_line,blocksize_y,blocksize_x,blocksize_x4,mcost,min_mcost,cand_x,cand_y);&#x2F;&#x2F;cost &#x3D; mv_cost + SAD<br>  McostState[search_range][search_range] &#x3D; mcost;<br>  if (mcost &lt; min_mcost)<br>  {<br>    min_mcost &#x3D; mcost;<br>    best_x &#x3D; cand_x;<br>    best_y &#x3D; cand_y;<br>  }</p>
<p>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;<br>  for (m &#x3D; 0; m &lt; 4; m++) &#x2F;&#x2F;小菱形检测<br>  {<br>    cand_x &#x3D; iXMinNow + Diamond_x[m];<br>    cand_y &#x3D; iYMinNow + Diamond_y[m];<br>    SEARCH_ONE_PIXEL<br>  }<br>&#x2F;<em><strong><strong><strong><strong><strong><strong><strong><strong>原点检测</strong></strong></strong></strong></strong></strong></strong></strong></em>**********************&#x2F;<br>  if(center_x !&#x3D; pic_pix_x || center_y !&#x3D; pic_pix_y)<br>  {<br>    cand_x &#x3D; pic_pix_x ;<br>    cand_y &#x3D; pic_pix_y ;<br>    SEARCH_ONE_PIXEL</p>
<pre><code>iXMinNow = best_x;
iYMinNow = best_y;
for (m = 0; m &lt; 4; m++)//小菱形检测
&#123;   
  cand_x = iXMinNow + Diamond_x[m]; 
  cand_y = iYMinNow + Diamond_y[m];   
  SEARCH_ONE_PIXEL
&#125; 
</code></pre>
<p>  }<br> &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>上层块预测矢量检测</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><em><strong>********&#x2F;<br>    if(blocktype&gt;1)&#x2F;&#x2F;<br>  {<br>    cand_x &#x3D; pic_pix_x + (pred_MV_uplayer[0]&#x2F;4);<br>    cand_y &#x3D; pic_pix_y + (pred_MV_uplayer[1]&#x2F;4);<br>    SEARCH_ONE_PIXEL<br>    if ((min_mcost-pred_SAD_uplayer)&lt;pred_SAD_uplayer<em>betaThird)<br>      goto third_step;<br>    else if((min_mcost-pred_SAD_uplayer)&lt;pred_SAD_uplayer</em>betaSec)<br>      goto sec_step;<br>  }<br>    &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong>相应块预测</strong></strong></strong></strong></strong></strong></strong></strong>******</strong>****</em>**********&#x2F;</p>
<p>  &#x2F;&#x2F;coordinate position prediction<br>  if ((img-&gt;number &gt; 1 + ref &amp;&amp; ref!&#x3D;-1) || (list &#x3D;&#x3D; 1 &amp;&amp; (Bframe_ctr%N_Bframe) &gt; 1))  &#x2F;&#x2F;for debug<br>  {<br>    cand_x &#x3D; pic_pix_x + pred_MV_time[0]&#x2F;4;<br>    cand_y &#x3D; pic_pix_y + pred_MV_time[1]&#x2F;4;<br>    SEARCH_ONE_PIXEL<br>  }<br>  &#x2F;<strong><strong><strong><strong><strong><strong><strong><strong><strong>相邻参考帧预测</strong></strong></strong></strong></strong></strong></strong></strong></strong>***************&#x2F;</p>
<p>  &#x2F;&#x2F;prediciton using mV of last ref moiton vector<br>  if (input-&gt;PicInterlace &#x3D;&#x3D; FIELD_CODING)&#x2F;&#x2F;场编码，用最近的场MV预测<br>  {<br>    if ((list&#x3D;&#x3D;0 &amp;&amp; ref &gt; 0) || (img-&gt;type &#x3D;&#x3D; B_SLICE &amp;&amp; list &#x3D;&#x3D; 0 &amp;&amp; (ref&#x3D;&#x3D;0 ||ref&#x3D;&#x3D;2 ) ))<br>      &#x2F;&#x2F;Notes: for interlace case, ref&#x3D;&#x3D;1 should be added<br>    {<br>      cand_x &#x3D; pic_pix_x + pred_MV_ref[0]&#x2F;4;<br>      cand_y &#x3D; pic_pix_y + pred_MV_ref[1]&#x2F;4;<br>      SEARCH_ONE_PIXEL<br>    }<br>  }<br>  else<br>  {   &#x2F;&#x2F;多参考帧预测时，用另一帧的MV预测<br>    if ((list&#x3D;&#x3D;0 &amp;&amp; ref &gt; 0) || (img-&gt;type &#x3D;&#x3D; B_SLICE &amp;&amp; list &#x3D;&#x3D; 0 &amp;&amp; ref&#x3D;&#x3D;0 ))<br>      &#x2F;&#x2F;Notes: for interlace case, ref&#x3D;&#x3D;1 should be added<br>    {<br>      cand_x &#x3D; pic_pix_x + pred_MV_ref[0]&#x2F;4;<br>      cand_y &#x3D; pic_pix_y + pred_MV_ref[1]&#x2F;4;<br>      SEARCH_ONE_PIXEL<br>    }<br>  }<br>  &#x2F;&#x2F;small local search<br>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;<br>  for (m &#x3D; 0; m &lt; 4; m++)&#x2F;&#x2F;小菱形搜索<br>  {<br>    cand_x &#x3D; iXMinNow + Diamond_x[m];<br>    cand_y &#x3D; iYMinNow + Diamond_y[m];<br>    SEARCH_ONE_PIXEL<br>  } </p>
<p>  &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>   &#x2F;&#x2F;根据SAD值判断需要跳转的步骤，SAD较小时转到步骤3，较大时转到步骤2，很大时转到步骤1<br>    EARLY_TERMINATION</p>
<p>  if(blocktype&gt;6)<br>    goto sec_step;<br>  else<br>    goto first_step;</p>
<p>first_step: &#x2F;&#x2F;Unsymmetrical-cross search 不甚满意<br>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;</p>
<p>  for(i&#x3D;1;i&lt;&#x3D;search_range&#x2F;2;i++)&#x2F;&#x2F;水平方向搜索<br>  {<br>    search_step &#x3D; 2*i - 1;<br>    cand_x &#x3D; iXMinNow + search_step;<br>    cand_y &#x3D; iYMinNow ;<br>    SEARCH_ONE_PIXEL<br>    cand_x &#x3D; iXMinNow - search_step;<br>    cand_y &#x3D; iYMinNow ;<br>    SEARCH_ONE_PIXEL<br>  }</p>
<p>  &#x2F;&#x2F;垂直方向搜索，注意垂直方向搜索点比水平方向少，考虑到了水平方向较垂直方向重要<br>  for(i&#x3D;1;i&lt;&#x3D;search_range&#x2F;4;i++)<br>  {<br>    search_step &#x3D; 2*i - 1;<br>    cand_x &#x3D; iXMinNow ;<br>    cand_y &#x3D; iYMinNow + search_step;<br>    SEARCH_ONE_PIXEL<br>    cand_x &#x3D; iXMinNow ;<br>    cand_y &#x3D; iYMinNow - search_step;<br>    SEARCH_ONE_PIXEL<br>  }<br>  &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>    &#x2F;&#x2F;在这里也进行中止、跳转检测，考虑到一般序列中含有大量水平、垂直方向的运动。<br>    EARLY_TERMINATION</p>
<p>  iXMinNow &#x3D; best_x;<br>  iYMinNow &#x3D; best_y;<br>    &#x2F;&#x2F;螺旋搜索，类似全搜索法，只搜索前25点，相当于5×5区域全搜索<br>  for(pos&#x3D;1;pos&lt;25;pos++)<br>  {<br>    cand_x &#x3D; iXMinNow + spiral_search_x[pos];<br>    cand_y &#x3D; iYMinNow + spiral_search_y[pos];<br>    SEARCH_ONE_PIXEL<br>  }<br>  &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>    EARLY_TERMINATION</p>
<p>   &#x2F;&#x2F; Uneven Multi-Hexagon-grid Search<br>    &#x2F;&#x2F;超六边形模板搜索，（多圈）<br>  for(i&#x3D;1;i&lt;&#x3D;search_range&#x2F;4; i++)<br>  {<br>    iAbort &#x3D; 0;<br>    for (m &#x3D; 0; m &lt; 16; m++)<br>    {<br>      cand_x &#x3D; iXMinNow + Big_Hexagon_x[m]*i;<br>      cand_y &#x3D; iYMinNow + Big_Hexagon_y[m]*i;<br>      SEARCH_ONE_PIXEL1(1)<br>    }<br>    if (iAbort)<br>    {<br>      &#x2F;&#x2F;early termination algrithm, refer to JVT-D016<br>      EARLY_TERMINATION<br>    }<br>  }</p>
<p>&#x2F;&#x2F; 六边形模板反复搜索（也可以用大菱形代替），搜索完后进入第三步骤<br>sec_step:  &#x2F;&#x2F;Extended Hexagon-based Search 满意<br>      iXMinNow &#x3D; best_x;<br>      iYMinNow &#x3D; best_y;<br>      for(i&#x3D;0;i&lt;search_range;i++)<br>      {<br>        iAbort &#x3D; 1;<br>        for (m &#x3D; 0; m &lt; 6; m++)<br>        {<br>          cand_x &#x3D; iXMinNow + Hexagon_x[m];<br>          cand_y &#x3D; iYMinNow + Hexagon_y[m];<br>          SEARCH_ONE_PIXEL1(0)<br>        }<br>        if(iAbort)<br>          break;<br>        iXMinNow &#x3D; best_x;<br>        iYMinNow &#x3D; best_y;<br>      }<br>&#x2F;&#x2F; 小菱形模板反复搜索，得到最终的运动矢量<br>third_step: &#x2F;&#x2F; the third step with a small search pattern  很满意<br>      iXMinNow &#x3D; best_x;<br>      iYMinNow &#x3D; best_y;<br>      for(i&#x3D;0;i&lt;search_range;i++)<br>      {<br>        iSADLayer &#x3D; 65536;<br>        iAbort &#x3D; 1;<br>        for (m &#x3D; 0; m &lt; 4; m++)<br>        {<br>          cand_x &#x3D; iXMinNow + Diamond_x[m];<br>          cand_y &#x3D; iYMinNow + Diamond_y[m];<br>          SEARCH_ONE_PIXEL1(0)<br>        }<br>        if(iAbort)<br>          break;<br>        iXMinNow &#x3D; best_x;<br>        iYMinNow &#x3D; best_y;<br>      }</p>
<pre><code>  *mv_x = best_x - pic_pix_x;
  *mv_y = best_y - pic_pix_y; 
  return min_mcost;
</code></pre>
<p>  }</p>

  <div class="guide-links">
    
    
  </div>

    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">欧长坤</a> &copy; 2016-2025 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>



</div>

	</div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
