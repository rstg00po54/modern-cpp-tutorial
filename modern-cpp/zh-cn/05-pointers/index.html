

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>第 5 章 智能指针与内存管理 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-zh-cn"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="现代 C++ 教程" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp/">
    
      <img src="/modern-cpp/assets/cover-2nd-logo.png">
      <span>现代 C++ 教程：高速上手 C++ 11/14/17/20</span>
    
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      
        <li class="nav-dropdown-container resource">
  <a class="nav-link">资源</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><ul>
      <li><a class="nav-link" href="/modern-cpp/zh-cn/00-preface/" >正文</a></li>
      <!-- TODO -->
      <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >代码</a></li>
      <li><a class="nav-link" href="/modern-cpp/exercises/1/" >习题</a></li>
      <li><a class="nav-link" href="/modern-cpp/answers/1/" >答案</a></li> -->
    </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link">关于</a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" href="/modern-cpp/about/donate.html" >资助</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >版权声明</a></li>
      <li><a class="nav-link" href="/modern-cpp/about/ack.html" >致谢</a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container language">
  <a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    中文
  </a><span class="arrow"></span>
  <ul class="nav-dropdown">
      <li><ul>
      <li><a class="nav-link" target="_blank" href="/modern-cpp/en-us/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        English
      </a></li>
      </ul></li>
  </ul>
</li>

<li class="nav-dropdown-container about">
  <a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>


      
    </ul>
    <div class="list">
      <h2>
        
          正文
        
      </h2>
      <ul class="menu-root">
  
    <li>
      <a href="/modern-cpp/zh-cn/00-preface/index.html" class="sidebar-link">序言</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/01-intro/index.html" class="sidebar-link">第 1 章 迈向现代 C++</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/02-usability/index.html" class="sidebar-link">第 2 章 语言可用性的强化</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/03-runtime/index.html" class="sidebar-link">第 3 章 语言运行期的强化</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/04-containers/index.html" class="sidebar-link">第 4 章 容器</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/05-pointers/index.html" class="sidebar-link current">第 5 章 智能指针与内存管理</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/06-regex/index.html" class="sidebar-link">第 6 章 正则表达式</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/07-thread/index.html" class="sidebar-link">第 7 章 并行与并发</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/08-filesystem/index.html" class="sidebar-link">第 8 章 文件系统</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/09-others/index.html" class="sidebar-link">第 9 章 其他杂项</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/10-cpp20/index.html" class="sidebar-link">第 10 章 展望：C++20 简介</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/appendix1/index.html" class="sidebar-link">附录 1：进一步阅读的学习材料</a>
    </li>
  
    <li>
      <a href="/modern-cpp/zh-cn/appendix2/index.html" class="sidebar-link">附录 2：现代 C++ 的最佳实践</a>
    </li>
  
</ul>

    </div>
  </div>
</div>


<div class="content book-zh-cn with-sidebar index-guide">
  <h1 id="第-5-章-智能指针与内存管理"><a href="#第-5-章-智能指针与内存管理" class="headerlink" title="第 5 章 智能指针与内存管理"></a>第 5 章 智能指针与内存管理</h1><h2 id="5-1-RAII-与引用计数"><a href="#5-1-RAII-与引用计数" class="headerlink" title="5.1 RAII 与引用计数"></a>5.1 RAII 与引用计数</h2><p>了解 <code>Objective-C</code>/<code>Swift</code> 的程序员应该知道引用计数的概念。引用计数这种计数是为了防止内存泄露而产生的。
基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次，
每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。</p>
<p>在传统 C++ 中，『记得』手动释放资源，总不是最佳实践。因为我们很有可能就忘记了去释放资源而导致泄露。
所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在离开作用域时调用）的时候释放空间，
也就是我们常说的 RAII 资源获取即初始化技术。</p>
<p>凡事都有例外，我们总会有需要将对象在自由存储上分配的需求，在传统 C++ 里我们只好使用 <code>new</code> 和 <code>delete</code> 去
『记得』对资源进行释放。而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序员不再需要关心手动释放内存。
这些智能指针包括 <code>std::shared_ptr</code>/<code>std::unique_ptr</code>/<code>std::weak_ptr</code>，使用它们需要包含头文件 <code>&lt;memory&gt;</code>。</p>
<blockquote>
<p>注意：引用计数不是垃圾回收，引用计数能够尽快收回不再被使用的对象，同时在回收的过程中也不会造成长时间的等待，
更能够清晰明确的表明资源的生命周期。</p>
</blockquote>
<h2 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 <code>std::shared_ptr</code></h2><p><code>std::shared_ptr</code> 是一种智能指针，它能够记录多少个 <code>shared_ptr</code> 共同指向一个对象，从而消除显式的调用
<code>delete</code>，当引用计数变为零的时候就会将对象自动删除。</p>
<p>但还不够，因为使用 <code>std::shared_ptr</code> 仍然需要使用 <code>new</code> 来调用，这使得代码出现了某种程度上的不对称。</p>
<p><code>std::make_shared</code> 就能够用来消除显式的使用 <code>new</code>，所以<code>std::make_shared</code> 会分配创建传入参数中的对象，
并返回这个对象类型的<code>std::shared_ptr</code>指针。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(std::shared_ptr&lt;<span class="keyword">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">    (*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line">    <span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    <span class="keyword">auto</span> pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">foo</span>(pointer);</span><br><span class="line">    std::cout &lt;&lt; *pointer &lt;&lt; std::endl; <span class="comment">// 11</span></span><br><span class="line">    <span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::shared_ptr</code> 可以通过 <code>get()</code> 方法来获取原始指针，通过 <code>reset()</code> 来减少一个引用计数，
并通过<code>use_count()</code>来查看一个对象的引用计数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = std::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="keyword">auto</span> pointer3 = pointer; <span class="comment">// 引用计数+1</span></span><br><span class="line"><span class="keyword">int</span> *p = pointer.<span class="built_in">get</span>();  <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">pointer2.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 2</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer2 已 reset; 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span> &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line">pointer3.<span class="built_in">reset</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;reset pointer3:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.<span class="built_in">use_count</span>() &lt;&lt; std::endl;   <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;pointer3.use_count() = &quot;</span></span><br><span class="line">          &lt;&lt; pointer3.<span class="built_in">use_count</span>() &lt;&lt; std::endl;           <span class="comment">// pointer3 已 reset; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 <code>std::unique_ptr</code></h2><p><code>std::unique_ptr</code> 是一种独占的智能指针，它禁止其他智能指针与其共享同一个对象，从而保证代码的安全：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; pointer = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>make_unique</code> 并不复杂，C++11 没有提供 <code>std::make_unique</code>，可以自行实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::unique_ptr&lt;T&gt;( <span class="keyword">new</span> <span class="built_in">T</span>( std::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么没有提供，C++ 标准委员会主席 Herb Sutter 在他的<a target="_blank" rel="noopener" href="https://herbsutter.com/gotw/_102/">博客</a>中提到原因是因为『被他们忘记了』。</p>
</blockquote>
<p>既然是独占，换句话说就是不可复制。但是，我们可以利用 <code>std::move</code> 将其转移给其他的 <code>unique_ptr</code>，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Foo::~Foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Foo::foo&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Foo &amp;)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;f(const Foo&amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p1</span><span class="params">(std::make_unique&lt;Foo&gt;())</span></span>;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::unique_ptr&lt;Foo&gt; <span class="title">p2</span><span class="params">(std::move(p1))</span></span>;</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="built_in">f</span>(*p2);</span><br><span class="line">        <span class="comment">// p2 不空, 输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        <span class="comment">// p1 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        p1 = std::<span class="built_in">move</span>(p2);</span><br><span class="line">        <span class="comment">// p2 为空, 无输出</span></span><br><span class="line">        <span class="keyword">if</span>(p2) p2-&gt;<span class="built_in">foo</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;p2 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p1 不空, 输出</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="comment">// Foo 的实例会在离开作用域时被销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-std-weak-ptr"><a href="#5-4-std-weak-ptr" class="headerlink" title="5.4 std::weak_ptr"></a>5.4 <code>std::weak_ptr</code></h2><p>如果你仔细思考 <code>std::shared_ptr</code> 就会发现依然存在着资源无法释放的问题。看下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;B&gt; pointer;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;A&gt; pointer;</span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = std::make_shared&lt;A&gt;();</span><br><span class="line">    <span class="keyword">auto</span> b = std::make_shared&lt;B&gt;();</span><br><span class="line">    a-&gt;pointer = b;</span><br><span class="line">    b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 <code>a,b</code>，这使得 <code>a,b</code> 的引用计数均变为了 2，而离开作用域时，<code>a,b</code> 智能指针被析构，却只能造成这块区域的引用计数减一，这样就导致了 <code>a,b</code> 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了内存泄露，如图 5.1：</p>
<p><img src="../../assets/figures/pointers1.png" alt="图 5.1"><span class="image-caption">图 5.1</span></p>
<p>解决这个问题的办法就是使用弱引用指针 <code>std::weak_ptr</code>，<code>std::weak_ptr</code>是一种弱引用（相比较而言 <code>std::shared_ptr</code> 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的释放流程如图 5.2 所示：</p>
<p><img src="../../assets/figures/pointers2.png" alt="图 5.2"><span class="image-caption">图 5.2</span></p>
<p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。</p>
<p><code>std::weak_ptr</code> 没有 <code>*</code> 运算符和 <code>-&gt;</code> 运算符，所以不能够对资源进行操作，它可以用于检查 <code>std::shared_ptr</code> 是否存在，其 <code>expired()</code> 方法能在资源未被释放时，会返回 <code>false</code>，否则返回 <code>true</code>；除此之外，它也可以用于获取指向原始对象的 <code>std::shared_ptr</code> 指针，其 <code>lock()</code> 方法在原始对象未被释放时，返回一个指向原始对象的 <code>std::shared_ptr</code> 指针，进而访问原始对象的资源，否则返回<code>nullptr</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>智能指针这种技术并不新奇，在很多语言中都是一种常见的技术，现代 C++ 将这项技术引进，在一定程度上消除了 <code>new</code>/<code>delete</code> 的滥用，是一种更加成熟的编程范式。</p>
<h2 id="进一步阅读的参考资料"><a href="#进一步阅读的参考资料" class="headerlink" title="进一步阅读的参考资料"></a>进一步阅读的参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12580432/why-does-c11-have-make-shared-but-not-make-unique">stackoverflow 上关于『C++11为什么没有 make_unique』的讨论</a></li>
</ol>

  <div class="guide-links">
    
      <span>← <a href="/modern-cpp/zh-cn/04-containers/index.html">第 4 章 容器</a></span>
    
    
      <span style="float: right;"><a href="/modern-cpp/zh-cn/06-regex/index.html">第 6 章 正则表达式</a> →</span>
    
  </div>

  
    <div class="footer">
        <p>
          <a href="https://changkun.de">欧长坤</a> &copy; 2016-2025 版权所有，
          采用<a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议许可</a>，代码使用 <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> 协议开源。</a>
        </p>
        <p>
            如果你认为本书对你起到了帮助，可以<a href="/modern-cpp/about/donate.html">资助作者</a>。
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
