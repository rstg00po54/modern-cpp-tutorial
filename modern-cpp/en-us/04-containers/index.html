

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Chapter 04 Containers 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-en-us"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="Modern C++ Tutorial" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp/">
    
      <img src="/modern-cpp/assets/cover-2nd-en-logo.png">
      <span>Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</span>
    
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      
        <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

      
    </ul>
    <div class="list">
      <h2>
        
          Book-en-us
        
      </h2>
      <ul class="menu-root">
  
    <li>
      <a href="/modern-cpp/en-us/00-preface/index.html" class="sidebar-link">Preface</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/01-intro/index.html" class="sidebar-link">Chapter 01: Towards Modern C++</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/02-usability/index.html" class="sidebar-link">Chapter 02: Language Usability Enhancements</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/03-runtime/index.html" class="sidebar-link">Chapter 03: Language Runtime Enhancements</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/04-containers/index.html" class="sidebar-link current">Chapter 04 Containers</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/05-pointers/index.html" class="sidebar-link">Chapter 05 Smart Pointers and Memory Management</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/06-regex/index.html" class="sidebar-link">Chapter 06 Regular Expression</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/07-thread/index.html" class="sidebar-link">Chapter 07 Parallelism and Concurrency</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/08-filesystem/index.html" class="sidebar-link">Chapter 08 File System</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/09-others/index.html" class="sidebar-link">Chapter 09 Minor Features</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/10-cpp20/index.html" class="sidebar-link">Chapter 10 Outlook: Introduction of C++20</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/appendix1/index.html" class="sidebar-link">Appendix 1: Further Study Materials</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/appendix2/index.html" class="sidebar-link">Appendix 2: Modern C++ Best Practices</a>
    </li>
  
</ul>

    </div>
  </div>
</div>


<div class="content book-en-us with-sidebar index-guide">
  <h1 id="Chapter-04-Containers"><a href="#Chapter-04-Containers" class="headerlink" title="Chapter 04 Containers"></a>Chapter 04 Containers</h1><h2 id="4-1-Linear-Container"><a href="#4-1-Linear-Container" class="headerlink" title="4.1 Linear Container"></a>4.1 Linear Container</h2><h3 id="std-array"><a href="#std-array" class="headerlink" title="std::array"></a><code>std::array</code></h3><p>When you see this container, you will have this problem:</p>
<ol>
<li>Why introduce <code>std::array</code> instead of <code>std::vector</code> directly?</li>
<li>Already have a traditional array, why use <code>std::array</code>?</li>
</ol>
<p>First, answer the first question. Unlike <code>std::vector</code>, the size of the <code>std::array</code> object is fixed. If the container size is fixed, then the <code>std::array</code> container can be used first.
Also, since <code>std::vector</code> is automatically expanded, when a large amount of data is stored, and the container is deleted,
The container does not automatically return the corresponding memory of the deleted element. In this case, you need to manually run <code>shrink_to_fit()</code> to release this part of the memory.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// output 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// output 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// As you can see, the storage of std::vector is automatically managed and</span></span><br><span class="line"><span class="comment">// automatically expanded as needed.</span></span><br><span class="line"><span class="comment">// But if there is not enough space, you need to redistribute more memory,</span></span><br><span class="line"><span class="comment">// and reallocating memory is usually a performance-intensive operation.</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// output 3</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// output 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The auto-expansion logic here is very similar to Golang&#x27;s slice.</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// output 5</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// output 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// As can be seen below, although the container empties the element,</span></span><br><span class="line"><span class="comment">// the memory of the emptied element is not returned.</span></span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// output 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// output 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Additional memory can be returned to the system via the shrink_to_fit() call</span></span><br><span class="line">v.<span class="built_in">shrink_to_fit</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;size:&quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; std::endl;         <span class="comment">// output 0</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;capacity:&quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; std::endl; <span class="comment">// output 0</span></span><br></pre></td></tr></table></figure>

<p>The second problem is much simpler. Using <code>std::array</code> can make the code more &quot;modern&quot; and encapsulate some manipulation functions, such as getting the array size and checking if it is not empty, and also using the standard friendly. Container algorithms in the library, such as <code>std::sort</code>.</p>
<p>Using <code>std::array</code> is as simple as specifying its type and size:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">arr.<span class="built_in">empty</span>(); <span class="comment">// check if container is empty</span></span><br><span class="line">arr.<span class="built_in">size</span>();  <span class="comment">// return the size of the container</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator support</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use lambda expression for sort</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> b &lt; a;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// array size must be constexpr</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> len = <span class="number">4</span>;</span><br><span class="line">std::array&lt;<span class="keyword">int</span>, len&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// illegal, different than C-style array, std::array will not deduce to T*</span></span><br><span class="line"><span class="comment">// int *arr_p = arr;</span></span><br></pre></td></tr></table></figure>

<p>When we started using <code>std::array</code>, it was inevitable that we would encounter a C-style compatible interface. There are three ways to do this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="keyword">int</span>, 4&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C-stype parameter passing</span></span><br><span class="line"><span class="comment">// foo(arr, arr.size()); // illegal, cannot convert implicitly</span></span><br><span class="line"><span class="built_in">foo</span>(&amp;arr[<span class="number">0</span>], arr.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">foo</span>(arr.<span class="built_in">data</span>(), arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// use `std::sort`</span></span><br><span class="line">std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<h3 id="std-forward-list"><a href="#std-forward-list" class="headerlink" title="std::forward_list"></a><code>std::forward_list</code></h3><p><code>std::forward_list</code> is a list container, and the usage is similar to <code>std::list</code>, so we don&#39;t spend a lot of time introducing it.</p>
<p>Need to know is that, unlike the implementation of the doubly linked list of <code>std::list</code>, <code>std::forward_list</code> is implemented using a singly linked list.
Provides element insertion of <code>O(1)</code> complexity, does not support fast random access (this is also a feature of linked lists),
It is also the only container in the standard library container that does not provide the <code>size()</code> method. Has a higher space utilization than <code>std::list</code> when bidirectional iteration is not required.</p>
<h2 id="4-2-Unordered-Container"><a href="#4-2-Unordered-Container" class="headerlink" title="4.2 Unordered Container"></a>4.2 Unordered Container</h2><p>We are already familiar with the ordered container <code>std::map</code>/<code>std::set</code> in traditional C++. These elements are internally implemented by red-black trees.
The average complexity of inserts and searches is <code>O(log(size))</code>. When inserting an element, the element size is compared according to the <code>&lt;</code> operator and the element is determined to be the same.
And select the appropriate location to insert into the container. When traversing the elements in this container, the output will be traversed one by one in the order of the <code>&lt;</code> operator.</p>
<p>The elements in the unordered container are not sorted, and the internals is implemented by the Hash table. The average complexity of inserting and searching for elements is <code>O(constant)</code>,
Significant performance gains can be achieved without concern for the order of the elements inside the container.</p>
<p>C++11 introduces two unordered containers: <code>std::unordered_map</code>/<code>std::unordered_multimap</code> and
<code>std::unordered_set</code>/<code>std::unordered_multiset</code>.</p>
<p>Their usage is basically similar to the original <code>std::map</code>/<code>std::multimap</code>/<code>std::set</code>/<code>set::multiset</code>
Since these containers are already familiar to us, we will not compare them one by one. Let&#39;s compare <code>std::map</code> and <code>std::unordered_map</code> directly:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// initialized in same order</span></span><br><span class="line">    std::unordered_map&lt;<span class="keyword">int</span>, std::string&gt; u = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::map&lt;<span class="keyword">int</span>, std::string&gt; v = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;1&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="string">&quot;3&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="string">&quot;2&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterates in the same way</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::unordered_map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span> &amp; n : u)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;std::map&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span> &amp; n : v)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Key:[&quot;</span> &lt;&lt; n.first &lt;&lt; <span class="string">&quot;] Value:[&quot;</span> &lt;&lt; n.second &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The final output is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unordered_map</span><br><span class="line">Key:[2] Value:[2]</span><br><span class="line">Key:[3] Value:[3]</span><br><span class="line">Key:[1] Value:[1]</span><br><span class="line"></span><br><span class="line">std::map</span><br><span class="line">Key:[1] Value:[1]</span><br><span class="line">Key:[2] Value:[2]</span><br><span class="line">Key:[3] Value:[3]</span><br></pre></td></tr></table></figure>

<h2 id="4-3-Tuples"><a href="#4-3-Tuples" class="headerlink" title="4.3 Tuples"></a>4.3 Tuples</h2><p>Programmers who have known Python should be aware of the concept of tuples. Looking at the containers in traditional C++, except for <code>std::pair</code>
there seems to be no ready-made structure to store different types of data (usually we will define the structure ourselves).
But the flaw of <code>std::pair</code> is obvious, only two elements can be saved.</p>
<h3 id="Basic-Operations"><a href="#Basic-Operations" class="headerlink" title="Basic Operations"></a>Basic Operations</h3><p>There are three core functions for the use of tuples:</p>
<ol>
<li><code>std::make_tuple</code>: construct tuple</li>
<li><code>std::get</code>: Get the value of a position in the tuple</li>
<li><code>std::tie</code>: tuple unpacking</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">3.8</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">2.9</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1.7</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;Ive&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// it is not allowed to return 0 directly</span></span><br><span class="line">    <span class="comment">// return type is std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0.0</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&quot;null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> student = <span class="built_in">get_student</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;GPA: &quot;</span>   &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Grade: &quot;</span> &lt;&lt; std::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Name: &quot;</span>  &lt;&lt; std::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> gpa;</span><br><span class="line">    <span class="keyword">char</span> grade;</span><br><span class="line">    std::string name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unpack tuples</span></span><br><span class="line">    std::<span class="built_in">tie</span>(gpa, grade, name) = <span class="built_in">get_student</span>(<span class="number">1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;GPA: &quot;</span>   &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Grade: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Name: &quot;</span>  &lt;&lt; name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>std::get</code> In addition to using constants to get tuple objects, C++14 adds usage types to get objects in tuples:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::tuple&lt;std::string, <span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(<span class="string">&quot;123&quot;</span>, <span class="number">4.5</span>, <span class="number">6.7</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;std::string&gt;(t) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; std::endl; <span class="comment">// illegal, runtime error</span></span><br><span class="line">std::cout &lt;&lt; std::get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="Runtime-Indexing"><a href="#Runtime-Indexing" class="headerlink" title="Runtime Indexing"></a>Runtime Indexing</h3><p>If you think about it, you might find the problem with the above code. <code>std::get&lt;&gt;</code> depends on a compile-time constant, so the following is not legal:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">std::get&lt;index&gt;(t);</span><br></pre></td></tr></table></figure>

<p>So what do you do? The answer is to use <code>std::variant&lt;&gt;</code> (introduced by C++ 17) to provide type template parameters for <code>variant&lt;&gt;</code>
You can have a <code>variant&lt;&gt;</code> to accommodate several types of variables provided (in other languages, such as Python/JavaScript, etc., as dynamic types):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;variant&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> n, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; _tuple_index(<span class="keyword">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="keyword">size_t</span> i) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(n &gt;= <span class="keyword">sizeof</span>...(T))</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throw</span> <span class="title">std::out_of_range</span><span class="params">(<span class="string">&quot;越界.&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (i == n)</span><br><span class="line">        <span class="keyword">return</span> std::variant&lt;T...&gt;&#123; std::in_place_index&lt;n&gt;, std::get&lt;n&gt;(tpl) &#125;;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;(n &lt; <span class="keyword">sizeof</span>...(T)<span class="number">-1</span> ? n+<span class="number">1</span> : <span class="number">0</span>)&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> std::variant&lt;T...&gt; <span class="title">tuple_index</span><span class="params">(<span class="keyword">const</span> std::tuple&lt;T...&gt;&amp; tpl, <span class="keyword">size_t</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _tuple_index&lt;<span class="number">0</span>&gt;(tpl, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt; (std::ostream &amp; s, std::variant&lt;T0, Ts...&gt; <span class="keyword">const</span> &amp; v) &#123;</span><br><span class="line">    std::<span class="built_in">visit</span>([&amp;](<span class="keyword">auto</span> &amp;&amp; x)&#123; s &lt;&lt; x;&#125;, v);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>So we can:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">tuple_index</span>(t, i) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="Merge-and-Iteration"><a href="#Merge-and-Iteration" class="headerlink" title="Merge and Iteration"></a>Merge and Iteration</h3><p>Another common requirement is to merge two tuples, which can be done with <code>std::tuple_cat</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> new_tuple = std::<span class="built_in">tuple_cat</span>(<span class="built_in">get_student</span>(<span class="number">1</span>), std::<span class="built_in">move</span>(t));</span><br></pre></td></tr></table></figure>

<p>You can immediately see how quickly you can traverse a tuple? But we just introduced how to index a <code>tuple</code> by a very number at runtime, then the traversal becomes simpler.
First, we need to know the length of a tuple, which can:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">tuple_len</span><span class="params">(T &amp;tpl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::tuple_size&lt;T&gt;::value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This will iterate over the tuple:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="built_in">tuple_len</span>(new_tuple); ++i)</span><br><span class="line">    <span class="comment">// runtime indexing</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">tuple_index</span>(new_tuple, i) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This chapter briefly introduces the new containers in modern C++. Their usage is similar to that of the existing containers in C++. It is relatively simple, and you can choose the containers you need to use according to the actual scene, to get better performance.</p>
<p>Although <code>std::tuple</code> is effective, the standard library provides limited functionality and there is no way to meet the requirements of runtime indexing and iteration. Fortunately, we have other methods that we can implement on our own.</p>

  <div class="guide-links">
    
      <span>← <a href="/modern-cpp/en-us/03-runtime/index.html">Chapter 03: Language Runtime Enhancements</a></span>
    
    
      <span style="float: right;"><a href="/modern-cpp/en-us/05-pointers/index.html">Chapter 05 Smart Pointers and Memory Management</a> →</span>
    
  </div>

  
    <div class="footer">
        <p>
          <a href="https://changkun.de">Changkun Ou</a> &copy; 2016-2025.
          The book is licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0</a>, code is open sourced under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> License. </a>
        </p>
        <p>
          If you like the book, you could <a href="/modern-cpp/about/donate.html">donate the author</a>.
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
