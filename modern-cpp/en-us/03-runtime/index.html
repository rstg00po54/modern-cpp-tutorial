

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Chapter 03: Language Runtime Enhancements 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp-tutorial/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-en-us"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 7.3.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="Modern C++ Tutorial" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp-tutorial/">
      <img src="/modern-cpp-tutorial/modern-cpp/assets/cover-2nd-logo.png">
      <span>教程：高速上手</span>
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      
        <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp-tutorial/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

      
    </ul>
    <div class="list">
      <h2>
        
          Book-en-us
        
      </h2>
      <ul class="menu-root">
	  <!-- 引入外部的 JS 文件 -->
  <!-- <script src="/modern-cpp/js/menu.js"></script> -->

	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/00-preface/index.html" 
			class="sidebar-link"
			>
			Preface
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/01-intro/index.html" 
			class="sidebar-link"
			>
			Chapter 01: Towards Modern C++
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/02-usability/index.html" 
			class="sidebar-link"
			>
			Chapter 02: Language Usability Enhancements
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/03-runtime/index.html" 
			class="sidebar-link current"
			>
			Chapter 03: Language Runtime Enhancements
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/04-containers/index.html" 
			class="sidebar-link"
			>
			Chapter 04 Containers
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/05-pointers/index.html" 
			class="sidebar-link"
			>
			Chapter 05 Smart Pointers and Memory Management
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/06-regex/index.html" 
			class="sidebar-link"
			>
			Chapter 06 Regular Expression
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/07-thread/index.html" 
			class="sidebar-link"
			>
			Chapter 07 Parallelism and Concurrency
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/08-filesystem/index.html" 
			class="sidebar-link"
			>
			Chapter 08 File System
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/09-others/index.html" 
			class="sidebar-link"
			>
			Chapter 09 Minor Features
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/10-cpp20/index.html" 
			class="sidebar-link"
			>
			Chapter 10 Outlook: Introduction of C++20
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/appendix1/index.html" 
			class="sidebar-link"
			>
			Appendix 1: Further Study Materials
		</a>
		</li>
	

		<li>
		  <a 
			href="/modern-cpp-tutorial/modern-cpp/en-us/appendix2/index.html" 
			class="sidebar-link"
			>
			Appendix 2: Modern C++ Best Practices
		</a>
		</li>
	
  <!-- 传递数据到 JavaScript -->
  

  Hello from myHelper!


</ul>

    </div>
  </div>
</div>


<div class="content book-en-us with-sidebar index-guide">
  <h1 id="Chapter-03-Language-Runtime-Enhancements"><a href="#Chapter-03-Language-Runtime-Enhancements" class="headerlink" title="Chapter 03: Language Runtime Enhancements"></a>Chapter 03: Language Runtime Enhancements</h1><h2 id="3-1-Lambda-Expression"><a href="#3-1-Lambda-Expression" class="headerlink" title="3.1 Lambda Expression"></a>3.1 Lambda Expression</h2><p>Lambda expressions are one of the most important features in modern C++, and Lambda expressions provide a feature like anonymous functions.<br>Anonymous functions are used when a function is needed, but you don’t want to use a name to call a function. There are many, many scenes like this.<br>So anonymous functions are almost standard in modern programming languages.</p>
<h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><p>The basic syntax of a Lambda expression is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list) mutable(optional) exception attribute -&gt; return type &#123;</span><br><span class="line">// function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above grammar rules are well understood except for the things in <code>[capture list]</code>,<br>except that the function name of the general function is omitted.<br>The return value is in the form of a <code>-&gt;</code><br>(we have already mentioned this in the tail return type earlier in the previous section).</p>
<p>The so-called capture list can be understood as a type of parameter.<br>The internal function body of a lambda expression cannot use variables outside<br>the body of the function by default.<br>At this time, the capture list can serve to transfer external data.<br>According to the behavior passed,<br>the capture list is also divided into the following types:</p>
<h4 id="1-Value-capture"><a href="#1-Value-capture" class="headerlink" title="1. Value capture"></a>1. Value capture</h4><p>Similar to parameter passing, the value capture is based on the fact that<br>the variable can be copied, except that the captured variable is copied<br>when the lambda expression is created, not when it is called:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// At this moment, stored_value == 1, and value == 100.</span></span><br><span class="line">    <span class="comment">// Because copy_value has copied when its was created.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Reference-capture"><a href="#2-Reference-capture" class="headerlink" title="2. Reference capture"></a>2. Reference capture</h4><p>Similar to a reference pass, the reference capture saves the reference and the value changes.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// At this moment, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// Because copy_value stores reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Implicit-capture"><a href="#3-Implicit-capture" class="headerlink" title="3. Implicit capture"></a>3. Implicit capture</h4><p>Manually writing a capture list is sometimes very complicated.<br>This mechanical work can be handled by the compiler.<br>At this point, you can write a <code>&amp;</code> or <code>=</code> to the compiler to<br>declare the reference or value capture.</p>
<p>To summarize, capture provides the ability for lambda expressions<br>to use external values. The four most common forms of<br>capture lists can be:</p>
<ul>
<li>[] empty capture list</li>
<li>[name1, name2, …] captures a series of variables</li>
<li>[&amp;] reference capture, determine the reference capture list from the uses the in function body</li>
<li>[&#x3D;] value capture, determine the value capture list from the uses in the function body</li>
</ul>
<h4 id="4-Expression-capture"><a href="#4-Expression-capture" class="headerlink" title="4. Expression capture"></a>4. Expression capture</h4><blockquote>
<p>This section needs to understand the rvalue references and smart pointers that<br>will be mentioned later.</p>
</blockquote>
<p>The value captures and reference captures mentioned above are variables that have been<br>declared in the outer scope, so these capture methods capture the lvalue<br>and not capture the rvalue.</p>
<p>C++14 gives us the convenience of allowing the captured members to be initialized<br>with arbitrary expressions, which allows the capture of rvalues.<br>The type of the captured variable being declared is judged according to the expression,<br>and the judgment is the same as using <code>auto</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above code, <code>important</code> is an exclusive pointer that cannot be caught by value capture using <code>=</code>.<br>At this time we need to transfer it to the rvalue and<br>initialize it in the expression.</p>
<h3 id="Generic-Lambda"><a href="#Generic-Lambda" class="headerlink" title="Generic Lambda"></a>Generic Lambda</h3><p>In the previous section, we mentioned that the <code>auto</code> keyword cannot be used<br>in the parameter list because it would conflict with the functionality of the template.<br>But lambda expressions are not regular functions, without further specification on the typed parameter list, lambda expressions cannot utilize templates. Fortunately, this trouble<br>only exists in C++11, starting with C++14. The formal parameters of the lambda function<br>can use the <code>auto</code> keyword to utilize template generics:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lambda_generic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> generic = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">generic</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">generic</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Function-Object-Wrapper"><a href="#3-2-Function-Object-Wrapper" class="headerlink" title="3.2 Function Object Wrapper"></a>3.2 Function Object Wrapper</h2><p>Although the features are part of the standard library and not found in runtime,<br>it enhances the runtime capabilities of the C++ language.<br>This part of the content is also very important, so put it here for the introduction.</p>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h3><p>The essence of a Lambda expression is an object of a class type (called a closure type)<br>that is similar to a function object type (called a closure object).<br>When the capture list of a Lambda expression is empty, the closure object<br>can also be converted to a function pointer value for delivery, for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in">void</span>(<span class="type">int</span>);  <span class="comment">// function pointer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="type">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f);  <span class="comment">// call by function pointer</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);           <span class="comment">// call by lambda expression</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above code gives two different forms of invocation, one is to call Lambda<br>as a function type, and the other is to directly call a Lambda expression.<br>In C++11, these concepts are unified.<br>The type of object that can be called is collectively called the callable type.<br>This type is introduced by <code>std::function</code>.</p>
<p>C++11 <code>std::function</code> is a generic, polymorphic function wrapper<br>whose instances can store, copy, and call any target entity that can be called.<br>It is also an existing callable to C++. A type-safe package of entities (relatively,<br>the call to a function pointer is not type-safe), in other words,<br>a container of functions. When we have a container for functions,<br>we can more easily handle functions and function pointers as objects. e.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function wraps a function that take int paremeter and returns int value</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; func2 = [&amp;](<span class="type">int</span> value) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-bind-and-std-placeholder"><a href="#std-bind-and-std-placeholder" class="headerlink" title="std::bind and std::placeholder"></a><code>std::bind</code> and <code>std::placeholder</code></h3><p>And <code>std::bind</code> is used to bind the parameters of the function call.<br>It solves the requirement that we may not always be able to get all the parameters<br>of a function at one time. Through this function, we can Part of the call parameters<br>are bound to the function in advance to become a new object,<br>and then complete the call after the parameters are complete. e.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bind parameter 1, 2 on function foo,</span></span><br><span class="line">    <span class="comment">// and use std::placeholders::_1 as placeholder for the first parameter.</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// when call bindFoo, we only need one param left</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tip:</strong> Note the magic of the <code>auto</code> keyword. Sometimes we may not be familiar<br>with the return type of a function, but we can circumvent this problem by using <code>auto</code>.</p>
</blockquote>
<h2 id="3-3-rvalue-Reference"><a href="#3-3-rvalue-Reference" class="headerlink" title="3.3 rvalue Reference"></a>3.3 rvalue Reference</h2><p>rvalue references are one of the important features introduced by C++11<br>that are synonymous with Lambda expressions. Its introduction solves<br>a large number of historical issues in C++.<br>Eliminating extra overhead such as <code>std::vector</code>, <code>std::string</code>,<br>and making the function object container <code>std::function</code> possible.</p>
<h3 id="lvalue-rvalue-prvalue-xvalue"><a href="#lvalue-rvalue-prvalue-xvalue" class="headerlink" title="lvalue, rvalue, prvalue, xvalue"></a>lvalue, rvalue, prvalue, xvalue</h3><p>To understand what the rvalue reference is all about, you must have a clear<br>understanding of the lvalue and the rvalue.</p>
<p><strong>lvalue, left value</strong>, as the name implies, is the value to the left of the assignment<br>symbol. To be precise, an lvalue is a persistent object that still exists after<br>an expression (not necessarily an assignment expression).</p>
<p><strong>Rvalue, right value</strong>, the value on the right refers to the temporary object<br>that no longer exists after the expression ends.</p>
<p>In C++11, in order to introduce powerful rvalue references,<br>the concept of rvalue values ​​is further divided into:<br>prvalue, and xvalue.</p>
<p><strong>pvalue, pure rvalue</strong>, purely rvalue, either purely literal,<br>such as <code>10</code>, <code>true</code>; either the result of the evaluation is equivalent to<br>a literal or anonymous temporary object, for example <code>1+2</code>.<br>Temporary variables returned by non-references, temporary variables generated<br>by operation expressions, original literals, and Lambda expressions<br>are all pure rvalue values.</p>
<p>Note that a literal (except a string literal) is a prvalue. However, a string<br>literal is an lvalue with type <code>const char</code> array. Consider the following examples:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Correct. The type of &quot;01234&quot; is const char [6], so it is an lvalue</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">char</span> <span class="params">(&amp;left)</span>[6] </span>= <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert success. It is a const char [6] indeed. Note that decltype(expr)</span></span><br><span class="line">    <span class="comment">// yields lvalue reference if expr is an lvalue and neither an unparenthesized</span></span><br><span class="line">    <span class="comment">// id-expression nor an unparenthesized class member access expression.</span></span><br><span class="line">    <span class="built_in">static_assert</span>(std::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="type">const</span> <span class="built_in">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error. &quot;01234&quot; is an lvalue, which cannot be referenced by an rvalue reference</span></span><br><span class="line">    <span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, an array can be implicitly converted to a corresponding pointer.The result, if not an lvalue reference, is an rvalue (xvalue if the result is an rvalue reference, prvalue otherwise):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>*   p    = <span class="string">&quot;01234&quot;</span>; <span class="comment">// Correct. &quot;01234&quot; is implicitly converted to const char*</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*&amp;&amp; pr   = <span class="string">&quot;01234&quot;</span>; <span class="comment">// Correct. &quot;01234&quot; is implicitly converted to const char*, which is a prvalue.</span></span><br><span class="line"><span class="comment">// const char*&amp; pl = &quot;01234&quot;; // Error. There is no type const char* lvalue</span></span><br></pre></td></tr></table></figure>

<p><strong>xvalue, expiring value</strong> is the concept proposed by C++11 to introduce<br>rvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts),<br>a value that is destroyed but can be moved.</p>
<p>It would be a little hard to understand the xvalue,<br>let’s look at the code like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>In such code, as far as the traditional understanding is concerned,<br>the return value <code>temp</code> of the function <code>foo</code> is internally created<br>and then assigned to <code>v</code>, whereas when <code>v</code> gets this object, the entire <code>temp</code> is copied.<br>And then destroy <code>temp</code>, if this <code>temp</code> is very large, this will cause a lot of extra<br>overhead (this is the problem that traditional C++ has been criticized for).<br>In the last line, <code>v</code> is the lvalue, and the value returned by <code>foo()</code> is<br>the rvalue (which is also a pure rvalue).</p>
<p>However, <code>v</code> can be caught by other variables, and the return value generated by <code>foo()</code><br>is used as a temporary value. Once copied by <code>v</code>, it will be destroyed immediately, and<br>cannot be obtained or modified. The xvalue defines behavior in which temporary values ​​can be<br>identified while being able to be moved.</p>
<p>After C++11, the compiler did some work for us, where the lvalue <code>temp</code><br>is subjected to this implicit rvalue conversion,<br>equivalent to <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>,<br>where <code>v</code> here moves the value returned by <code>foo</code> locally.<br>This is the move semantics we will mention later.</p>
<h3 id="rvalue-reference-and-lvalue-reference"><a href="#rvalue-reference-and-lvalue-reference" class="headerlink" title="rvalue reference and lvalue reference"></a>rvalue reference and lvalue reference</h3><p>To get a xvalue, you need to use the declaration of the rvalue reference: <code>T &amp;&amp;</code>,<br>where <code>T</code> is the type.<br>The statement of the rvalue reference extends the lifecycle of this temporary value,<br>and as long as the variable is alive, the xvalue will continue to survive.</p>
<p>C++11 provides the <code>std::move</code> method to unconditionally convert<br>lvalue parameters to rvalues.<br>With it we can easily get a rvalue temporary object, for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string  lv1 = <span class="string">&quot;string,&quot;</span>;       <span class="comment">// lv1 is a lvalue</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1;          // illegal, rvalue can&#x27;t ref to lvalue</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// legal, std::move can convert lvalue to rvalue</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl;      <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// legal, const lvalue reference can</span></span><br><span class="line">                                        <span class="comment">// extend temp variable&#x27;s lifecycle</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;;                   // illegal, const ref can&#x27;t be modified</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl;      <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2;      <span class="comment">// legal, rvalue ref extend lifecycle</span></span><br><span class="line">    rv2 += <span class="string">&quot;string&quot;</span>;                    <span class="comment">// legal, non-const reference can be modified</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl;      <span class="comment">// string,string,string,string</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2);                     <span class="comment">// output: lvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rv2</code> refers to an rvalue, but since it is a reference,<br><code>rv2</code> is still an lvalue.</p>
<p>Note that there is a very interesting historical issue here,<br>let’s look at the following code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int &amp;a = std::move(1); // illegal, non-const lvalue reference cannot ref rvalue</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;b = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// legal, const lvalue reference can</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first question, why not allow non-constant references to bind to non-lvalues?<br>This is because there is a logic error in this approach:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">(<span class="type">int</span> &amp; v)</span> </span>&#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">increase</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since <code>int&amp;</code> can’t reference a parameter of type <code>double</code>,<br>you must generate a temporary value to hold the value of <code>s</code>.<br>Thus, when <code>increase()</code> modifies this temporary value,<br><code>s</code> itself is not modified after the call is completed.</p>
<p>The second question, why do constant references allow binding to non-lvalues?<br>The reason is simple because Fortran needs it.</p>
<h3 id="Move-semantics"><a href="#Move-semantics" class="headerlink" title="Move semantics"></a>Move semantics</h3><p>Traditional C++ has designed the concept of copy&#x2F;copy for class objects<br>through copy constructors and assignment operators,<br>but to implement the movement of resources,<br>The caller must use the method of copying and then destructing first,<br>otherwise, you need to implement the interface of the mobile object yourself.<br>Imagine moving your home directly to your new home instead of<br>copying everything (rebuy) to your new home.<br>Throwing away (destroying) all the original things is a very anti-human thing.</p>
<p>Traditional C++ does not distinguish between the concepts of “mobile” and “copy”,<br>resulting in a large amount of data copying, wasting time and space.<br>The appearance of rvalue references solves the confusion of these two concepts,<br>for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *pointer;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.pointer)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// meaningless object copy</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123;</span><br><span class="line">        a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// avoid compiler optimization</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="type">bool</span> test)</span> </span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    <span class="keyword">if</span>(test) <span class="keyword">return</span> a; <span class="comment">// equal to static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;     <span class="comment">// equal to static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the code above:</p>
<ol>
<li>First construct two <code>A</code> objects inside <code>return_rvalue</code>, and get the output of the two constructors;</li>
<li>After the function returns, it will generate a xvalue, which is referenced by the moving structure of <code>A</code> (<code>A(A&amp;&amp;)</code>), thus extending the life cycle, and taking the pointer in the rvalue and saving it to <code>obj</code>. In the middle, the pointer to the xvalue is set to <code>nullptr</code>, which prevents the memory area from being destroyed.</li>
</ol>
<p>This avoids meaningless copy constructs and enhances performance.<br>Let’s take a look at an example involving a standard library:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>   <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>   <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use push_back(const T&amp;), copy</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use push_back(const T&amp;&amp;),</span></span><br><span class="line">    <span class="comment">// no copy the string will be moved to vector,</span></span><br><span class="line">    <span class="comment">// and therefore std::move can reduce copy cost</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// str is empty now</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Perfect-forwarding"><a href="#Perfect-forwarding" class="headerlink" title="Perfect forwarding"></a>Perfect forwarding</h3><p>As we mentioned earlier, the rvalue reference of a declaration is actually an lvalue.<br>This creates problems for us to parameterize (pass):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;          normal param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For <code>pass(1)</code>, although the value is the rvalue, since <code>v</code> is a reference, it is also an lvalue.<br>Therefore <code>reference(v)</code> will call <code>reference(int&amp;)</code> and output lvalue.<br>For <code>pass(l)</code>, <code>l</code> is an lvalue, why is it successfully passed to <code>pass(T&amp;&amp;)</code>?</p>
<p>This is based on the <strong>reference collapsing rule</strong>: In traditional C++, we are not able to continue to reference a reference type.<br>However,<br>C++ has relaxed this practice with the advent of rvalue references,<br>resulting in a reference collapse rule that allows us to reference references,<br>both lvalue and rvalue. But follow the rules below:</p>
<table>
<thead>
<tr>
<th align="center">Function parameter type</th>
<th align="center">Argument parameter type</th>
<th align="center">Post-derivation function parameter type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T&amp;</td>
<td align="center">lvalue ref</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;</td>
<td align="center">rvalue ref</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">lvalue ref</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">rvalue ref</td>
<td align="center">T&amp;&amp;</td>
</tr>
</tbody></table>
<p>Therefore, the use of <code>T&amp;&amp;</code> in a template function may not be able to make an rvalue reference, and when a lvalue is passed, a reference to this function will be derived as an lvalue.<br>More precisely, <strong>no matter what type of reference the template parameter is, the template parameter can be derived as a right reference type</strong> if and only if the argument type is a right reference.<br>This makes <code>v</code> successful delivery of lvalues.</p>
<p>Perfect forwarding is based on the above rules. The so-called perfect forwarding is to let us pass the parameters,<br>Keep the original parameter type (lvalue reference keeps lvalue reference, rvalue reference keeps rvalue reference).<br>To solve this problem, we should use <code>std::forward</code> to forward (pass) the parameters:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reference</span><span class="params">(<span class="type">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;          normal param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;       std::move param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;    std::forward param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The outputs are:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rvalue pass:</span><br><span class="line">          normal param passing: lvalue reference</span><br><span class="line">       std::move param passing: rvalue reference</span><br><span class="line">    std::forward param passing: rvalue reference</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; param passing: rvalue reference</span><br><span class="line">lvalue pass:</span><br><span class="line">          normal param passing: lvalue reference</span><br><span class="line">       std::move param passing: rvalue reference</span><br><span class="line">    std::forward param passing: lvalue reference</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; param passing: lvalue reference</span><br></pre></td></tr></table></figure>

<p>Regardless of whether the pass parameter is an lvalue or an rvalue, the normal pass argument will forward the argument as an lvalue.<br>So <code>std::move</code> will always accept an lvalue, which forwards the call to <code>reference(int&amp;&amp;)</code> to output the rvalue reference.</p>
<p>Only <code>std::forward</code> does not cause any extra copies and <strong>perfectly forwards</strong> (passes) the arguments of the function to other functions that are called internally.</p>
<p><code>std::forward</code> is the same as <code>std::move</code>, and nothing is done. <code>std::move</code> simply converts the lvalue to the rvalue.<br><code>std::forward</code> is just a simple conversion of the parameters. From the point of view of the phenomenon,<br><code>std::forward&lt;T&gt;(v)</code> is the same as <code>static_cast&lt;T&amp;&amp;&gt;(v)</code>.</p>
<p>Readers may be curious as to why a statement can return values for two types of returns.<br>Let’s take a quick look at the concrete implementation of <code>std::forward</code>. <code>std::forward</code> contains two overloads:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this implementation, the function of <code>std::remove_reference</code> is to eliminate references in the type.<br>And <code>std::is_lvalue_reference</code> is used to check if the type derivation is correct, in the second implementation of <code>std::forward</code>.<br>Check that the received value is indeed an lvalue, which in turn reflects the collapse rule.</p>
<p>When <code>std::forward</code> accepts an lvalue, <code>_Tp</code> is deduced to the lvalue, so the return value is the lvalue; and when it accepts the rvalue,<br><code>_Tp</code> is derived as an rvalue reference, and based on the collapse rule, the return value becomes the rvalue of <code>&amp;&amp; + &amp;&amp;</code>.<br>It can be seen that the principle of <code>std::forward</code> is to make clever use of the differences in template type derivation.</p>
<p>At this point, we can answer the question: Why is <code>auto&amp;&amp;</code> the safest way to use looping statements?<br>Because when <code>auto</code> is pushed to a different lvalue and rvalue reference, the collapsed combination with <code>&amp;&amp;</code> is perfectly forwarded.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This chapter introduces the most important runtime enhancements in modern C++, and I believe that all the features mentioned in this section are worth knowing:</p>
<p>Lambda expression</p>
<ol>
<li>Function object container std::function</li>
<li>rvalue reference</li>
</ol>
<h2 id="Further-Readings"><a href="#Further-Readings" class="headerlink" title="Further Readings"></a>Further Readings</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Design-Evolution-C-Bjarne-Stroustrup/dp/0201543303">Bjarne Stroustrup, The Design and Evolution of C++</a></li>
</ul>

  <div class="guide-links">
    
      <span>← <a href="/modern-cpp-tutorial/modern-cpp/en-us/02-usability/index.html">Chapter 02: Language Usability Enhancements</a></span>
    
    
      <span style="float: right;"><a href="/modern-cpp-tutorial/modern-cpp/en-us/04-containers/index.html">Chapter 04 Containers</a> →</span>
    
  </div>

  
    <div class="footer">
        <p>
          <a target="_blank" rel="noopener" href="https://changkun.de">Changkun Ou</a> &copy; 2016-2024.
          The book is licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0</a>, code is open sourced under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> License. </a>
        </p>
        <p>
          If you like the book, you could <a href="/modern-cpp/about/donate.html">donate the author</a>.
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp-tutorial/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
