

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Chapter 03: Language Runtime Enhancements 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-en-us"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="Modern C++ Tutorial" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp/">
    
      <img src="/modern-cpp/assets/cover-2nd-en-logo.png">
      <span>Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</span>
    
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      
        <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

      
    </ul>
    <div class="list">
      <h2>
        
          Book-en-us
        
      </h2>
      <ul class="menu-root">
  
    <li>
      <a href="/modern-cpp/en-us/00-preface/index.html" class="sidebar-link">Preface</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/01-intro/index.html" class="sidebar-link">Chapter 01: Towards Modern C++</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/02-usability/index.html" class="sidebar-link">Chapter 02: Language Usability Enhancements</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/03-runtime/index.html" class="sidebar-link current">Chapter 03: Language Runtime Enhancements</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/04-containers/index.html" class="sidebar-link">Chapter 04 Containers</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/05-pointers/index.html" class="sidebar-link">Chapter 05 Smart Pointers and Memory Management</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/06-regex/index.html" class="sidebar-link">Chapter 06 Regular Expression</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/07-thread/index.html" class="sidebar-link">Chapter 07 Parallelism and Concurrency</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/08-filesystem/index.html" class="sidebar-link">Chapter 08 File System</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/09-others/index.html" class="sidebar-link">Chapter 09 Minor Features</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/10-cpp20/index.html" class="sidebar-link">Chapter 10 Outlook: Introduction of C++20</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/appendix1/index.html" class="sidebar-link">Appendix 1: Further Study Materials</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/appendix2/index.html" class="sidebar-link">Appendix 2: Modern C++ Best Practices</a>
    </li>
  
</ul>

    </div>
  </div>
</div>


<div class="content book-en-us with-sidebar index-guide">
  <h1 id="Chapter-03-Language-Runtime-Enhancements"><a href="#Chapter-03-Language-Runtime-Enhancements" class="headerlink" title="Chapter 03: Language Runtime Enhancements"></a>Chapter 03: Language Runtime Enhancements</h1><h2 id="3-1-Lambda-Expression"><a href="#3-1-Lambda-Expression" class="headerlink" title="3.1 Lambda Expression"></a>3.1 Lambda Expression</h2><p>Lambda expressions are one of the most important features in modern C++, and Lambda expressions provide a feature like anonymous functions.
Anonymous functions are used when a function is needed, but you don’t want to use a name to call a function. There are many, many scenes like this.
So anonymous functions are almost standard in modern programming languages.</p>
<h3 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h3><p>The basic syntax of a Lambda expression is as follows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list) mutable(optional) exception attribute -&gt; return type &#123;</span><br><span class="line">// function body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above grammar rules are well understood except for the things in <code>[capture list]</code>,
except that the function name of the general function is omitted.
The return value is in the form of a <code>-&gt;</code>
(we have already mentioned this in the tail return type earlier in the previous section).</p>
<p>The so-called capture list can be understood as a type of parameter.
The internal function body of a lambda expression cannot use variables outside
the body of the function by default.
At this time, the capture list can serve to transfer external data.
According to the behavior passed,
the capture list is also divided into the following types:</p>
<h4 id="1-Value-capture"><a href="#1-Value-capture" class="headerlink" title="1. Value capture"></a>1. Value capture</h4><p>Similar to parameter passing, the value capture is based on the fact that
the variable can be copied, except that the captured variable is copied
when the lambda expression is created, not when it is called:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_value_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// At this moment, stored_value == 1, and value == 100.</span></span><br><span class="line">    <span class="comment">// Because copy_value has copied when its was created.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-Reference-capture"><a href="#2-Reference-capture" class="headerlink" title="2. Reference capture"></a>2. Reference capture</h4><p>Similar to a reference pass, the reference capture saves the reference and the value changes.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_reference_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> copy_value = [&amp;value] &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">auto</span> stored_value = <span class="built_in">copy_value</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;stored_value = &quot;</span> &lt;&lt; stored_value &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// At this moment, stored_value == 100, value == 100.</span></span><br><span class="line">    <span class="comment">// Because copy_value stores reference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Implicit-capture"><a href="#3-Implicit-capture" class="headerlink" title="3. Implicit capture"></a>3. Implicit capture</h4><p>Manually writing a capture list is sometimes very complicated.
This mechanical work can be handled by the compiler.
At this point, you can write a <code>&amp;</code> or <code>=</code> to the compiler to
declare the reference or value capture.</p>
<p>To summarize, capture provides the ability for lambda expressions
to use external values. The four most common forms of
capture lists can be:</p>
<ul>
<li>[] empty capture list</li>
<li>[name1, name2, ...] captures a series of variables</li>
<li>[&amp;] reference capture, determine the reference capture list from the uses the in function body</li>
<li>[=] value capture, determine the value capture list from the uses in the function body</li>
</ul>
<h4 id="4-Expression-capture"><a href="#4-Expression-capture" class="headerlink" title="4. Expression capture"></a>4. Expression capture</h4><blockquote>
<p>This section needs to understand the rvalue references and smart pointers that
will be mentioned later.</p>
</blockquote>
<p>The value captures and reference captures mentioned above are variables that have been
declared in the outer scope, so these capture methods capture the lvalue
and not capture the rvalue.</p>
<p>C++14 gives us the convenience of allowing the captured members to be initialized
with arbitrary expressions, which allows the capture of rvalues.
The type of the captured variable being declared is judged according to the expression,
and the judgment is the same as using <code>auto</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span>  <span class="comment">// std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span> <span class="comment">// std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> important = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = std::<span class="built_in">move</span>(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above code, <code>important</code> is an exclusive pointer that cannot be caught by value capture using <code>=</code>.
At this time we need to transfer it to the rvalue and
initialize it in the expression.</p>
<h3 id="Generic-Lambda"><a href="#Generic-Lambda" class="headerlink" title="Generic Lambda"></a>Generic Lambda</h3><p>In the previous section, we mentioned that the <code>auto</code> keyword cannot be used
in the parameter list because it would conflict with the functionality of the template.
But lambda expressions are not regular functions, without further specification on the typed parameter list, lambda expressions cannot utilize templates. Fortunately, this trouble
only exists in C++11, starting with C++14. The formal parameters of the lambda function
can use the <code>auto</code> keyword to utilize template generics:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_generic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> generic = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">generic</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">generic</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Function-Object-Wrapper"><a href="#3-2-Function-Object-Wrapper" class="headerlink" title="3.2 Function Object Wrapper"></a>3.2 Function Object Wrapper</h2><p>Although the features are part of the standard library and not found in runtime,
it enhances the runtime capabilities of the C++ language.
This part of the content is also very important, so put it here for the introduction.</p>
<h3 id="std-function"><a href="#std-function" class="headerlink" title="std::function"></a><code>std::function</code></h3><p>The essence of a Lambda expression is an object of a class type (called a closure type)
that is similar to a function object type (called a closure object).
When the capture list of a Lambda expression is empty, the closure object
can also be converted to a function pointer value for delivery, for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> foo = <span class="built_in"><span class="keyword">void</span></span>(<span class="keyword">int</span>);  <span class="comment">// function pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [](<span class="keyword">int</span> value) &#123;</span><br><span class="line">        std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">functional</span>(f);  <span class="comment">// call by function pointer</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="number">1</span>);           <span class="comment">// call by lambda expression</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The above code gives two different forms of invocation, one is to call Lambda
as a function type, and the other is to directly call a Lambda expression.
In C++11, these concepts are unified.
The type of object that can be called is collectively called the callable type.
This type is introduced by <code>std::function</code>.</p>
<p>C++11 <code>std::function</code> is a generic, polymorphic function wrapper
whose instances can store, copy, and call any target entity that can be called.
It is also an existing callable to C++. A type-safe package of entities (relatively,
the call to a function pointer is not type-safe), in other words,
a container of functions. When we have a container for functions,
we can more easily handle functions and function pointers as objects. e.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// std::function wraps a function that take int paremeter and returns int value</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-bind-and-std-placeholder"><a href="#std-bind-and-std-placeholder" class="headerlink" title="std::bind and std::placeholder"></a><code>std::bind</code> and <code>std::placeholder</code></h3><p>And <code>std::bind</code> is used to bind the parameters of the function call.
It solves the requirement that we may not always be able to get all the parameters
of a function at one time. Through this function, we can Part of the call parameters
are bound to the function in advance to become a new object,
and then complete the call after the parameters are complete. e.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bind parameter 1, 2 on function foo,</span></span><br><span class="line">    <span class="comment">// and use std::placeholders::_1 as placeholder for the first parameter.</span></span><br><span class="line">    <span class="keyword">auto</span> bindFoo = std::<span class="built_in">bind</span>(foo, std::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// when call bindFoo, we only need one param left</span></span><br><span class="line">    <span class="built_in">bindFoo</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Tip:</strong> Note the magic of the <code>auto</code> keyword. Sometimes we may not be familiar
with the return type of a function, but we can circumvent this problem by using <code>auto</code>.</p>
</blockquote>
<h2 id="3-3-rvalue-Reference"><a href="#3-3-rvalue-Reference" class="headerlink" title="3.3 rvalue Reference"></a>3.3 rvalue Reference</h2><p>rvalue references are one of the important features introduced by C++11
that are synonymous with Lambda expressions. Its introduction solves
a large number of historical issues in C++.
Eliminating extra overhead such as <code>std::vector</code>, <code>std::string</code>,
and making the function object container <code>std::function</code> possible.</p>
<h3 id="lvalue-rvalue-prvalue-xvalue"><a href="#lvalue-rvalue-prvalue-xvalue" class="headerlink" title="lvalue, rvalue, prvalue, xvalue"></a>lvalue, rvalue, prvalue, xvalue</h3><p>To understand what the rvalue reference is all about, you must have a clear
understanding of the lvalue and the rvalue.</p>
<p><strong>lvalue, left value</strong>, as the name implies, is the value to the left of the assignment
symbol. To be precise, an lvalue is a persistent object that still exists after
an expression (not necessarily an assignment expression).</p>
<p><strong>Rvalue, right value</strong>, the value on the right refers to the temporary object
that no longer exists after the expression ends.</p>
<p>In C++11, in order to introduce powerful rvalue references,
the concept of rvalue values ​​is further divided into:
prvalue, and xvalue.</p>
<p><strong>pvalue, pure rvalue</strong>, purely rvalue, either purely literal,
such as <code>10</code>, <code>true</code>; either the result of the evaluation is equivalent to
a literal or anonymous temporary object, for example <code>1+2</code>.
Temporary variables returned by non-references, temporary variables generated
by operation expressions, original literals, and Lambda expressions
are all pure rvalue values.</p>
<p>Note that a literal (except a string literal) is a prvalue. However, a string
literal is an lvalue with type <code>const char</code> array. Consider the following examples:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Correct. The type of &quot;01234&quot; is const char [6], so it is an lvalue</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">char</span> <span class="params">(&amp;left)</span>[6] </span>= <span class="string">&quot;01234&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert success. It is a const char [6] indeed. Note that decltype(expr)</span></span><br><span class="line">    <span class="comment">// yields lvalue reference if expr is an lvalue and neither an unparenthesized</span></span><br><span class="line">    <span class="comment">// id-expression nor an unparenthesized class member access expression.</span></span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="built_in"><span class="keyword">char</span></span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error. &quot;01234&quot; is an lvalue, which cannot be referenced by an rvalue reference</span></span><br><span class="line">    <span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>However, an array can be implicitly converted to a corresponding pointer.The result, if not an lvalue reference, is an rvalue (xvalue if the result is an rvalue reference, prvalue otherwise):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*   p    = <span class="string">&quot;01234&quot;</span>; <span class="comment">// Correct. &quot;01234&quot; is implicitly converted to const char*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*&amp;&amp; pr   = <span class="string">&quot;01234&quot;</span>; <span class="comment">// Correct. &quot;01234&quot; is implicitly converted to const char*, which is a prvalue.</span></span><br><span class="line"><span class="comment">// const char*&amp; pl = &quot;01234&quot;; // Error. There is no type const char* lvalue</span></span><br></pre></td></tr></table></figure>

<p><strong>xvalue, expiring value</strong> is the concept proposed by C++11 to introduce
rvalue references (so in traditional C++, pure rvalue and rvalue are the same concepts),
a value that is destroyed but can be moved.</p>
<p>It would be a little hard to understand the xvalue,
let&#39;s look at the code like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; v = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure>

<p>In such code, as far as the traditional understanding is concerned,
the return value <code>temp</code> of the function <code>foo</code> is internally created
and then assigned to <code>v</code>, whereas when <code>v</code> gets this object, the entire <code>temp</code> is copied.
And then destroy <code>temp</code>, if this <code>temp</code> is very large, this will cause a lot of extra
overhead (this is the problem that traditional C++ has been criticized for).
In the last line, <code>v</code> is the lvalue, and the value returned by <code>foo()</code> is
the rvalue (which is also a pure rvalue).</p>
<p>However, <code>v</code> can be caught by other variables, and the return value generated by <code>foo()</code>
is used as a temporary value. Once copied by <code>v</code>, it will be destroyed immediately, and
cannot be obtained or modified. The xvalue defines behavior in which temporary values ​​can be
identified while being able to be moved.</p>
<p>After C++11, the compiler did some work for us, where the lvalue <code>temp</code>
is subjected to this implicit rvalue conversion,
equivalent to <code>static_cast&lt;std::vector&lt;int&gt; &amp;&amp;&gt;(temp)</code>,
where <code>v</code> here moves the value returned by <code>foo</code> locally.
This is the move semantics we will mention later.</p>
<h3 id="rvalue-reference-and-lvalue-reference"><a href="#rvalue-reference-and-lvalue-reference" class="headerlink" title="rvalue reference and lvalue reference"></a>rvalue reference and lvalue reference</h3><p>To get a xvalue, you need to use the declaration of the rvalue reference: <code>T &amp;&amp;</code>,
where <code>T</code> is the type.
The statement of the rvalue reference extends the lifecycle of this temporary value,
and as long as the variable is alive, the xvalue will continue to survive.</p>
<p>C++11 provides the <code>std::move</code> method to unconditionally convert
lvalue parameters to rvalues.
With it we can easily get a rvalue temporary object, for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(std::string&amp;&amp; str)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string  lv1 = <span class="string">&quot;string,&quot;</span>;       <span class="comment">// lv1 is a lvalue</span></span><br><span class="line">    <span class="comment">// std::string&amp;&amp; r1 = lv1;          // illegal, rvalue can&#x27;t ref to lvalue</span></span><br><span class="line">    std::string&amp;&amp; rv1 = std::<span class="built_in">move</span>(lv1); <span class="comment">// legal, std::move can convert lvalue to rvalue</span></span><br><span class="line">    std::cout &lt;&lt; rv1 &lt;&lt; std::endl;      <span class="comment">// string,</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> std::string&amp; lv2 = lv1 + lv1; <span class="comment">// legal, const lvalue reference can</span></span><br><span class="line">                                        <span class="comment">// extend temp variable&#x27;s lifecycle</span></span><br><span class="line">    <span class="comment">// lv2 += &quot;Test&quot;;                   // illegal, const ref can&#x27;t be modified</span></span><br><span class="line">    std::cout &lt;&lt; lv2 &lt;&lt; std::endl;      <span class="comment">// string,string,</span></span><br><span class="line"></span><br><span class="line">    std::string&amp;&amp; rv2 = lv1 + lv2;      <span class="comment">// legal, rvalue ref extend lifecycle</span></span><br><span class="line">    rv2 += <span class="string">&quot;string&quot;</span>;                    <span class="comment">// legal, non-const reference can be modified</span></span><br><span class="line">    std::cout &lt;&lt; rv2 &lt;&lt; std::endl;      <span class="comment">// string,string,string,string</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">reference</span>(rv2);                     <span class="comment">// output: lvalue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rv2</code> refers to an rvalue, but since it is a reference,
<code>rv2</code> is still an lvalue.</p>
<p>Note that there is a very interesting historical issue here,
let&#39;s look at the following code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int &amp;a = std::move(1); // illegal, non-const lvalue reference cannot ref rvalue</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp;b = std::<span class="built_in">move</span>(<span class="number">1</span>); <span class="comment">// legal, const lvalue reference can</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The first question, why not allow non-constant references to bind to non-lvalues?
This is because there is a logic error in this approach:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> &amp; v)</span> </span>&#123;</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">increase</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Since <code>int&amp;</code> can&#39;t reference a parameter of type <code>double</code>,
you must generate a temporary value to hold the value of <code>s</code>.
Thus, when <code>increase()</code> modifies this temporary value,
<code>s</code> itself is not modified after the call is completed.</p>
<p>The second question, why do constant references allow binding to non-lvalues?
The reason is simple because Fortran needs it.</p>
<h3 id="Move-semantics"><a href="#Move-semantics" class="headerlink" title="Move semantics"></a>Move semantics</h3><p>Traditional C++ has designed the concept of copy/copy for class objects
through copy constructors and assignment operators,
but to implement the movement of resources,
The caller must use the method of copying and then destructing first,
otherwise, you need to implement the interface of the mobile object yourself.
Imagine moving your home directly to your new home instead of
copying everything (rebuy) to your new home.
Throwing away (destroying) all the original things is a very anti-human thing.</p>
<p>Traditional C++ does not distinguish between the concepts of &quot;mobile&quot; and &quot;copy&quot;,
resulting in a large amount of data copying, wasting time and space.
The appearance of rvalue references solves the confusion of these two concepts,
for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> *pointer;</span><br><span class="line">    <span class="built_in">A</span>():<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;construct&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">pointer</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(*a.pointer)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;copy&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="comment">// meaningless object copy</span></span><br><span class="line">    <span class="built_in">A</span>(A&amp;&amp; a):<span class="built_in">pointer</span>(a.pointer) &#123;</span><br><span class="line">        a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;move&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;destruct&quot;</span> &lt;&lt; pointer &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span> pointer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// avoid compiler optimization</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="keyword">bool</span> test)</span> </span>&#123;</span><br><span class="line">    A a,b;</span><br><span class="line">    <span class="keyword">if</span>(test) <span class="keyword">return</span> a; <span class="comment">// equal to static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;     <span class="comment">// equal to static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A obj = <span class="built_in">return_rvalue</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; *obj.pointer &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the code above:</p>
<ol>
<li>First construct two <code>A</code> objects inside <code>return_rvalue</code>, and get the output of the two constructors;</li>
<li>After the function returns, it will generate a xvalue, which is referenced by the moving structure of <code>A</code> (<code>A(A&amp;&amp;)</code>), thus extending the life cycle, and taking the pointer in the rvalue and saving it to <code>obj</code>. In the middle, the pointer to the xvalue is set to <code>nullptr</code>, which prevents the memory area from being destroyed.</li>
</ol>
<p>This avoids meaningless copy constructs and enhances performance.
Let&#39;s take a look at an example involving a standard library:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span> <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>  <span class="comment">// std::move</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>   <span class="comment">// std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>   <span class="comment">// std::string</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::string str = <span class="string">&quot;Hello world.&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use push_back(const T&amp;), copy</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(str);</span><br><span class="line">    <span class="comment">// &quot;str: Hello world.&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use push_back(const T&amp;&amp;),</span></span><br><span class="line">    <span class="comment">// no copy the string will be moved to vector,</span></span><br><span class="line">    <span class="comment">// and therefore std::move can reduce copy cost</span></span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str));</span><br><span class="line">    <span class="comment">// str is empty now</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Perfect-forwarding"><a href="#Perfect-forwarding" class="headerlink" title="Perfect forwarding"></a>Perfect forwarding</h3><p>As we mentioned earlier, the rvalue reference of a declaration is actually an lvalue.
This creates problems for us to parameterize (pass):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;          normal param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For <code>pass(1)</code>, although the value is the rvalue, since <code>v</code> is a reference, it is also an lvalue.
Therefore <code>reference(v)</code> will call <code>reference(int&amp;)</code> and output lvalue.
For <code>pass(l)</code>, <code>l</code> is an lvalue, why is it successfully passed to <code>pass(T&amp;&amp;)</code>?</p>
<p>This is based on the <strong>reference collapsing rule</strong>: In traditional C++, we are not able to continue to reference a reference type.
However,
C++ has relaxed this practice with the advent of rvalue references,
resulting in a reference collapse rule that allows us to reference references,
both lvalue and rvalue. But follow the rules below:</p>
<table>
<thead>
<tr>
<th align="center">Function parameter type</th>
<th align="center">Argument parameter type</th>
<th align="center">Post-derivation function parameter type</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T&amp;</td>
<td align="center">lvalue ref</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;</td>
<td align="center">rvalue ref</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">lvalue ref</td>
<td align="center">T&amp;</td>
</tr>
<tr>
<td align="center">T&amp;&amp;</td>
<td align="center">rvalue ref</td>
<td align="center">T&amp;&amp;</td>
</tr>
</tbody></table>
<p>Therefore, the use of <code>T&amp;&amp;</code> in a template function may not be able to make an rvalue reference, and when a lvalue is passed, a reference to this function will be derived as an lvalue.
More precisely, <strong>no matter what type of reference the template parameter is, the template parameter can be derived as a right reference type</strong> if and only if the argument type is a right reference.
This makes <code>v</code> successful delivery of lvalues.</p>
<p>Perfect forwarding is based on the above rules. The so-called perfect forwarding is to let us pass the parameters,
Keep the original parameter type (lvalue reference keeps lvalue reference, rvalue reference keeps rvalue reference).
To solve this problem, we should use <code>std::forward</code> to forward (pass) the parameters:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span>&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue reference&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;          normal param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(v);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;       std::move param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::<span class="built_in">move</span>(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;    std::forward param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(std::forward&lt;T&gt;(v));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; param passing: &quot;</span>;</span><br><span class="line">    <span class="built_in">reference</span>(<span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pass</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;lvalue pass:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pass</span>(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The outputs are:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rvalue pass:</span><br><span class="line">          normal param passing: lvalue reference</span><br><span class="line">       std::move param passing: rvalue reference</span><br><span class="line">    std::forward param passing: rvalue reference</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; param passing: rvalue reference</span><br><span class="line">lvalue pass:</span><br><span class="line">          normal param passing: lvalue reference</span><br><span class="line">       std::move param passing: rvalue reference</span><br><span class="line">    std::forward param passing: lvalue reference</span><br><span class="line">static_cast&lt;T&amp;&amp;&gt; param passing: lvalue reference</span><br></pre></td></tr></table></figure>

<p>Regardless of whether the pass parameter is an lvalue or an rvalue, the normal pass argument will forward the argument as an lvalue.
So <code>std::move</code> will always accept an lvalue, which forwards the call to <code>reference(int&amp;&amp;)</code> to output the rvalue reference.</p>
<p>Only <code>std::forward</code> does not cause any extra copies and <strong>perfectly forwards</strong> (passes) the arguments of the function to other functions that are called internally.</p>
<p><code>std::forward</code> is the same as <code>std::move</code>, and nothing is done. <code>std::move</code> simply converts the lvalue to the rvalue.
<code>std::forward</code> is just a simple conversion of the parameters. From the point of view of the phenomenon,
<code>std::forward&lt;T&gt;(v)</code> is the same as <code>static_cast&lt;T&amp;&amp;&gt;(v)</code>.</p>
<p>Readers may be curious as to why a statement can return values for two types of returns.
Let&#39;s take a quick look at the concrete implementation of <code>std::forward</code>. <code>std::forward</code> contains two overloads:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> _Tp&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">        <span class="string">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this implementation, the function of <code>std::remove_reference</code> is to eliminate references in the type.
And <code>std::is_lvalue_reference</code> is used to check if the type derivation is correct, in the second implementation of <code>std::forward</code>.
Check that the received value is indeed an lvalue, which in turn reflects the collapse rule.</p>
<p>When <code>std::forward</code> accepts an lvalue, <code>_Tp</code> is deduced to the lvalue, so the return value is the lvalue; and when it accepts the rvalue,
<code>_Tp</code> is derived as an rvalue reference, and based on the collapse rule, the return value becomes the rvalue of <code>&amp;&amp; + &amp;&amp;</code>.
It can be seen that the principle of <code>std::forward</code> is to make clever use of the differences in template type derivation.</p>
<p>At this point, we can answer the question: Why is <code>auto&amp;&amp;</code> the safest way to use looping statements?
Because when <code>auto</code> is pushed to a different lvalue and rvalue reference, the collapsed combination with <code>&amp;&amp;</code> is perfectly forwarded.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This chapter introduces the most important runtime enhancements in modern C++, and I believe that all the features mentioned in this section are worth knowing:</p>
<p>Lambda expression</p>
<ol>
<li>Function object container std::function</li>
<li>rvalue reference</li>
</ol>
<h2 id="Further-Readings"><a href="#Further-Readings" class="headerlink" title="Further Readings"></a>Further Readings</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.amazon.com/Design-Evolution-C-Bjarne-Stroustrup/dp/0201543303">Bjarne Stroustrup, The Design and Evolution of C++</a></li>
</ul>

  <div class="guide-links">
    
      <span>← <a href="/modern-cpp/en-us/02-usability/index.html">Chapter 02: Language Usability Enhancements</a></span>
    
    
      <span style="float: right;"><a href="/modern-cpp/en-us/04-containers/index.html">Chapter 04 Containers</a> →</span>
    
  </div>

  
    <div class="footer">
        <p>
          <a href="https://changkun.de">Changkun Ou</a> &copy; 2016-2025.
          The book is licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0</a>, code is open sourced under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> License. </a>
        </p>
        <p>
          If you like the book, you could <a href="/modern-cpp/about/donate.html">donate the author</a>.
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
