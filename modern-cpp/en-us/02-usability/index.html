

<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Chapter 02: Language Usability Enhancements 现代 C++ 教程: 高速上手 C++ 11/14/17/20 - Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</title>
    <meta charset="utf-8">
    <meta name="description" content="Modern C++ Tutorial | C++ 11/14/17/20 On the Fly | 现代 C++ 教程 | 高速上手 C++11/14/17/20">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link rel="shortcut icon" type="image/x-icon" href="/modern-cpp/assets/cover-2nd.png">
    <meta name="msapplication-TileColor" content="#7e2d36">
    <meta name="theme-color" content="#7e2d36">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-80889616-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-80889616-2');
    </script>

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- main page styles -->
    
<link rel="stylesheet" href="/modern-cpp/css/page.css">


    <!-- this needs to be loaded before guide's inline scripts -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script>window.PAGE_TYPE = "book-en-us"</script>
    <script async src="//changkun.de/urlstat/client.js"></script>
  <meta name="generator" content="Hexo 5.4.0"></head>
  <body class="docs">
	<!-- body开始 -->
    
      <div id="mobile-bar" data-bg-text="Modern C++ Tutorial" >
        <a class="menu-button"></a>
        <a class="logo" href="/modern-cpp/"></a>
      </div>
    
    <div id="header">
  <a id="logo" href="/modern-cpp/">
    
      <img src="/modern-cpp/assets/cover-2nd-en-logo.png">
      <span>Modern C++ Tutorial: C++ 11/14/17/20 On the Fly</span>
    
  </a>
  <ul id="nav">
    
      <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

    
  </ul>
</div>

    
      <div id="main" class="fix-sidebar">
        
  <div class="sidebar">
  <div class="sidebar-inner">
    <ul class="main-menu">
      
        <li class="nav-dropdown-container resource">
<a class="nav-link">Resources</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/en-us/00-preface/" >Book</a></li>
    <!-- TODO -->
    <!-- <li><a class="nav-link" href="/modern-cpp/code/1/" >Code</a></li>
    <li><a class="nav-link" href="/modern-cpp/exercises/1/" >Exercise</a></li>
    <li><a class="nav-link" href="/modern-cpp/answers/1/" >Answers</a></li> -->
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link">About</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
    <li><a class="nav-link" href="/modern-cpp/about/donate.html" >Donate</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/copyright.html" >Copyright</a></li>
    <li><a class="nav-link" href="/modern-cpp/about/ack.html" >Acknowledgements</a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container language">
<a class="nav-link">
    <span style="content: url(/modern-cpp/assets/lang/en.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
    English
</a><span class="arrow"></span>
<ul class="nav-dropdown">
    <li><ul>
        <li><a class="nav-link" target="_blank" href="/modern-cpp/zh-cn/00-preface/">
        <span style="content: url(/modern-cpp/assets/lang/cn.svg); width: 15px; height: 15px; margin-right: 5px; vertical-align: middle; margin-bottom: 2px;"></span>
        中文
    </a></li>
    </ul></li>
</ul>
</li>

<li class="nav-dropdown-container about">
<a class="nav-link" target="_blank" rel="noopener" href="https://github.com/changkun/modern-cpp-tutorial">GitHub</a>
</li>

      
    </ul>
    <div class="list">
      <h2>
        
          Book-en-us
        
      </h2>
      <ul class="menu-root">
  
    <li>
      <a href="/modern-cpp/en-us/00-preface/index.html" class="sidebar-link">Preface</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/01-intro/index.html" class="sidebar-link">Chapter 01: Towards Modern C++</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/02-usability/index.html" class="sidebar-link current">Chapter 02: Language Usability Enhancements</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/03-runtime/index.html" class="sidebar-link">Chapter 03: Language Runtime Enhancements</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/04-containers/index.html" class="sidebar-link">Chapter 04 Containers</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/05-pointers/index.html" class="sidebar-link">Chapter 05 Smart Pointers and Memory Management</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/06-regex/index.html" class="sidebar-link">Chapter 06 Regular Expression</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/07-thread/index.html" class="sidebar-link">Chapter 07 Parallelism and Concurrency</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/08-filesystem/index.html" class="sidebar-link">Chapter 08 File System</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/09-others/index.html" class="sidebar-link">Chapter 09 Minor Features</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/10-cpp20/index.html" class="sidebar-link">Chapter 10 Outlook: Introduction of C++20</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/appendix1/index.html" class="sidebar-link">Appendix 1: Further Study Materials</a>
    </li>
  
    <li>
      <a href="/modern-cpp/en-us/appendix2/index.html" class="sidebar-link">Appendix 2: Modern C++ Best Practices</a>
    </li>
  
</ul>

    </div>
  </div>
</div>


<div class="content book-en-us with-sidebar index-guide">
  <h1 id="Chapter-02-Language-Usability-Enhancements"><a href="#Chapter-02-Language-Usability-Enhancements" class="headerlink" title="Chapter 02: Language Usability Enhancements"></a>Chapter 02: Language Usability Enhancements</h1><p>When we declare, define a variable or constant, and control the flow of code,
object-oriented functions, template programming, etc., before the runtime,
it may happen when writing code or compiler compiling code.
To this end, we usually talk about <strong>language usability</strong>,
which refers to the language behavior that occurred before the runtime.</p>
<h2 id="2-1-Constants"><a href="#2-1-Constants" class="headerlink" title="2.1 Constants"></a>2.1 Constants</h2><h3 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h3><p>The purpose of <code>nullptr</code> appears to replace <code>NULL</code>. There are <strong>null pointer constants</strong> in the C and C++ languages,
which can be implicitly converted to null pointer value of any pointer type,
or null member pointer value of any pointer-to-member type in C++.
<code>NULL</code> is provided by the standard library implementation and defined as an implementation-defined null pointer constant.
In C, some standard libraries defines <code>NULL</code> as <code>((void*)0)</code> and some define it as <code>0</code>.</p>
<p>C++ <strong>does not allow</strong> to implicitly convert <code>void *</code> to other types, and thus <code>((void*)0)</code> is not a valid implementation
of <code>NULL</code>. If the standard library tries to define <code>NULL</code> as <code>((void*)0)</code>, then compilation error would occur in the following code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>C++ without the <code>void *</code> implicit conversion has to define <code>NULL</code> as <code>0</code>.
This still creates a new problem. Defining <code>NULL</code> to <code>0</code> will cause the overloading feature in <code>C++</code> to be confusing.
Consider the following two <code>foo</code> functions:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Then the <code>foo(NULL);</code> statement will call <code>foo(int)</code>, which will cause the code to be counterintuitive.</p>
<p>To solve this problem, C++11 introduced the <code>nullptr</code> keyword, which is specifically used to distinguish null pointers, <code>0</code>. The type of <code>nullptr</code> is <code>nullptr_t</code>, which can be implicitly converted to any pointer or member pointer type, and can be compared equally or unequally with them.</p>
<p>You can try to compile the following code using clang++:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="keyword">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), std::<span class="keyword">nullptr_t</span>&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>);          <span class="comment">// will call foo(int)</span></span><br><span class="line">    <span class="comment">// foo(NULL);    // doesn&#x27;t compile</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);    <span class="comment">// will call foo(char*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span> *)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(char*) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The outputs are:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">foo(int) is called</span><br><span class="line">foo(char*) is called</span><br></pre></td></tr></table></figure>

<p>From the output we can see that <code>NULL</code> is different from <code>0</code> and <code>nullptr</code>.
So, develop the habit of using <code>nullptr</code> directly.</p>
<p>In addition, in the above code, we used <code>decltype</code> and
<code>std::is_same</code> which are modern C++ syntax.
In simple terms, <code>decltype</code> is used for type derivation,
and <code>std::is_same</code> is used to compare the equality of the two types.
We will discuss them in detail later in the <a href="#decltype">decltype</a> section.</p>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>C++ itself already has the concept of constant expressions, such as 1+2,
3*4. Such expressions always produce the same result without any side effects.
If the compiler can directly optimize and embed these expressions into the program at
compile-time, it will increase the performance of the program. A very obvious example
is in the definition phase of an array:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">len_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr_1[<span class="number">10</span>];                      <span class="comment">// legal</span></span><br><span class="line">    <span class="keyword">char</span> arr_2[LEN];                     <span class="comment">// legal</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// char arr_3[len];                  // illegal</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// char arr_4[len_2];                // illegal, but ok for most of the compilers</span></span><br><span class="line">    <span class="keyword">char</span> arr_4[len_2_constexpr];         <span class="comment">// legal</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char arr_5[len_foo()+5];          // illegal</span></span><br><span class="line">    <span class="keyword">char</span> arr_6[<span class="built_in">len_foo_constexpr</span>() + <span class="number">1</span>]; <span class="comment">// legal</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above example, <code>char arr_4[len_2]</code> may be confusing because <code>len_2</code> has been defined as a constant.
Why is <code>char arr_4[len_2]</code> still illegal?
This is because the length of the array in the C++ standard must be a constant expression,
and for <code>len_2</code>, this is a <code>const</code> constant, not a constant expression,
so even if this behavior is supported by most compilers, but it is an illegal behavior,
we need to use the <code>constexpr</code> feature introduced in C++11, which will be introduced next,
to solve this problem; for <code>arr_5</code>, before C++98 The compiler cannot know that <code>len_foo()</code>
actually returns a constant at runtime, which causes illegal production.</p>
<blockquote>
<p>Note that most compilers now have their compiler optimizations.
Many illegal behaviors become legal under the compiler&#39;s optimization.
If you need to reproduce the error, you need to use the old version of the compiler.</p>
</blockquote>
<p>C++11 provides <code>constexpr</code> to let the user explicitly declare that the function or
object constructor will become a constant expression at compile time.
This keyword explicitly tells the compiler that it should verify that <code>len_foo</code>
should be a compile-time constant expression.</p>
<p>In addition, the function of <code>constexpr</code> can use recursion:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Starting with C++14,
the constexpr function can use simple statements such as local variables,
loops, and branches internally.
For example, the following code cannot be compiled under the C++11 standard:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To do this, we can write a simplified version like this
to make the function available from C++11:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Variables-and-initialization"><a href="#2-2-Variables-and-initialization" class="headerlink" title="2.2 Variables and initialization"></a>2.2 Variables and initialization</h2><h3 id="if-switch"><a href="#if-switch" class="headerlink" title="if-switch"></a>if-switch</h3><p>In traditional C++, the declaration of a variable can declare a temporary variable <code>int</code>
even though it can be located anywhere, even within a <code>for</code> statement,
but there is always no way to declare a temporary variable in the <code>if</code> and <code>switch</code> statements.
E.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// since c++17, can be simplified by using `auto`</span></span><br><span class="line">    <span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">        itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// should output: 1, 4, 3, 4. can be simplified using `auto`</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="keyword">int</span>&gt;::iterator element = vec.<span class="built_in">begin</span>(); element != vec.<span class="built_in">end</span>(); </span><br><span class="line">        ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above code, we can see that the <code>itr</code> variable is defined in the scope of
the entire <code>main()</code>, which causes us to rename the other when a variable need to traverse
the entire <code>std::vector</code> again. C++17 eliminates this limitation so that
we can do this in if(or switch):</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> std::vector&lt;<span class="keyword">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Is it similar to the Go?</p>
<h3 id="Initializer-list"><a href="#Initializer-list" class="headerlink" title="Initializer list"></a>Initializer list</h3><p>Initialization is a very important language feature,
the most common one is when the object is initialized.
In traditional C++, different objects have different initialization methods,
such as ordinary arrays, PODs (<strong>P</strong>lain <strong>O</strong>ld <strong>D</strong>ata,
i.e. classes without constructs, destructors, and virtual functions)
Or struct type can be initialized with <code>&#123;&#125;</code>,
which is what we call the initialization list.
For the initialization of the class object,
you need to use the copy construct,
or you need to use <code>()</code>.
These different methods are specific to each other and cannot be generic.
E.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value_a;</span><br><span class="line">    <span class="keyword">int</span> value_b;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b) : <span class="built_in">value_a</span>(a), <span class="built_in">value_b</span>(b) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// before C++11</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr[0]: &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo:&quot;</span> &lt;&lt; foo.value_a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; foo.value_b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="keyword">int</span>&gt;::iterator it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To solve this problem,
C++11 first binds the concept of the initialization list to the type
and calls it <code>std::initializer_list</code>,
allowing the constructor or other function to use the initialization list
like a parameter, which is the initialization of class objects provides
a unified bridge between normal arrays and POD initialization methods,
such as:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="keyword">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">             it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after C++11</span></span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="keyword">int</span>&gt;::iterator it = magicFoo.vec.<span class="built_in">begin</span>(); </span><br><span class="line">        it != magicFoo.vec.<span class="built_in">end</span>(); ++it) </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This constructor is called the initialize list constructor, and the type with
this constructor will be specially taken care of during initialization.</p>
<p>In addition to the object construction, the initialization list can also
be used as a formal parameter of a normal function, for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(std::initializer_list&lt;<span class="keyword">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="keyword">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">            it != list.<span class="built_in">end</span>(); ++it) vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.<span class="built_in">foo</span>(&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>Second, C++11 also provides a uniform syntax for initializing arbitrary objects, such as:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Foo foo2 &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Structured-binding"><a href="#Structured-binding" class="headerlink" title="Structured binding"></a>Structured binding</h3><p>Structured bindings provide functionality similar to the multiple return values
provided in other languages. In the chapter on containers,
we will learn that C++11 has added a <code>std::tuple</code> container for
constructing a tuple that encloses multiple return values. But the flaw
is that C++11/14 does not provide a simple way to get and define
the elements in the tuple from the tuple,
although we can unpack the tuple using <code>std::tie</code>
But we still have to be very clear about how many objects this tuple contains,
what type of each object is, very troublesome.</p>
<p>C++17 completes this setting,
and the structured bindings let us write code like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>auto</code> type derivation is described in the
<a href="#auto">auto type inference</a> section.</p>
<h2 id="2-3-Type-inference"><a href="#2-3-Type-inference" class="headerlink" title="2.3 Type inference"></a>2.3 Type inference</h2><p>In traditional C and C++, the types of parameters must be clearly defined, which does not help us to quickly encode, especially when we are faced with a large number of complex template types, we must indicate the type of variables to proceed. Subsequent coding, which not only slows down our development efficiency but also makes the code stinking and long.</p>
<p>C++11 introduces the two keywords <code>auto</code> and <code>decltype</code> to implement type derivation, letting the compiler worry about the type of the variable. This makes C++ the same as other modern programming languages, in a way that provides the habit of not having to worry about variable types.</p>
<h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><p><code>auto</code> has been in C++ for a long time, but it always exists as an indicator of a storage type, coexisting with <code>register</code>. In traditional C++, if a variable is not declared as a <code>register</code> variable, it is automatically treated as an <code>auto</code> variable. And with <code>register</code> being deprecated (used as a reserved keyword in C++17 and later used, it doesn&#39;t currently make sense), the semantic change to <code>auto</code> is very natural.</p>
<p>One of the most common and notable examples of type derivation using <code>auto</code> is the iterator. You should see the lengthy iterative writing in traditional C++ in the previous section:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before C++11</span></span><br><span class="line"><span class="comment">// cbegin() returns vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// and therefore it is type vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); it != vec.<span class="built_in">cend</span>(); ++it)</span><br></pre></td></tr></table></figure>

<p>When we have <code>auto</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="keyword">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Some other common usages:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;              <span class="comment">// i as int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="built_in"><span class="keyword">auto</span></span>(<span class="number">10</span>); <span class="comment">// arr as int *</span></span><br></pre></td></tr></table></figure>

<p>Since C++ 14, <code>auto</code> can even be used as function arguments in generic lambda expressions,
and such functionality is generalized to normal functions in C++ 20.
Consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> add14 = [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add20</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// type int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// type int</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add14</span>(i, j) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add20</span>(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Note</strong>: <code>auto</code> cannot be used to derive array types yet:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;;   <span class="comment">// illegal, can&#x27;t infer array type</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.6</span>.<span class="keyword">auto</span>.cpp:<span class="number">30</span>:<span class="number">19</span>: error: <span class="string">&#x27;auto_arr2&#x27;</span> declared as array of <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">    <span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>The <code>decltype</code> keyword is used to solve the defect that the auto keyword
can only type the variable. Its usage is very similar to <code>typeof</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(expression)</span><br></pre></td></tr></table></figure>

<p>Sometimes we may need to calculate the type of an expression, for example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure>

<p>You have seen in the previous example that
<code>decltype</code> is used to infer the usage of the type.
The following example is to determine
if the above variables <code>x, y, z</code> are of the same type:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">int</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">float</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == float&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">decltype</span>(z)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type z == type x&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>Among them, <code>std::is_same&lt;T, U&gt;</code> is used to determine whether
the two types <code>T</code> and <code>U</code> are equal. The output is:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type x == int</span><br><span class="line">type z == type x</span><br></pre></td></tr></table></figure>

<h3 id="tail-type-inference"><a href="#tail-type-inference" class="headerlink" title="tail type inference"></a>tail type inference</h3><p>You may think that whether <code>auto</code> can be used to deduce the return type of a function. Still consider an example of an add function, which we have to write in traditional C++:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note: There is no difference between typename and class in the template parameter list. Before the keyword typename appears, class is used to define the template parameters. However, when defining a variable with <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names">nested dependency type</a> in the template, you need to use typename to eliminate ambiguity.</p>
</blockquote>
<p>Such code is very ugly because the programmer must explicitly
indicate the return type when using this template function.
But in fact, we don&#39;t know what kind of operation
the <code>add()</code> function will do, and what kind of return type to get.</p>
<p>This problem was solved in C++11. Although you may immediately
react to using <code>decltype</code> to derive the type of <code>x+y</code>,
write something like this:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(x+y) <span class="built_in">add</span>(T x, U y)</span><br></pre></td></tr></table></figure>

<p>But in fact, this way of writing can not be compiled.
This is because <code>x</code> and <code>y</code> have not been defined
when the compiler reads decltype(x+y).
To solve this problem, C++11 also introduces a trailing return type,
which uses the auto keyword to post the return type:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The good news is that from C++14 it is possible to directly derive the return value of
a normal function, so the following way becomes legal:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can check if the type derivation is correct:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// after c++11</span></span><br><span class="line"><span class="keyword">auto</span> w = add2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(w), <span class="keyword">double</span>&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w is double: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after c++14</span></span><br><span class="line"><span class="keyword">auto</span> q = add3&lt;<span class="keyword">double</span>, <span class="keyword">int</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h3 id="decltype-auto"><a href="#decltype-auto" class="headerlink" title="decltype(auto)"></a>decltype(auto)</h3><p><code>decltype(auto)</code> is a slightly more complicated use of C++14.</p>
<blockquote>
<p>To understand it you need to know the concept of parameter forwarding
in C++, which we will cover in detail in the
<a href="../03-runtime/index.html">Language Runtime Enhancements</a> chapter,
and you can come back to the contents of this section later.</p>
</blockquote>
<p>In simple terms, <code>decltype(auto)</code> is mainly used to derive
the return type of a forwarding function or package,
which does not require us to explicitly specify
the parameter expression of <code>decltype</code>.
Consider the following example, when we need to wrap the following
two functions:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string  <span class="title">lookup1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">lookup2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>In C++11:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>With <code>decltype(auto)</code>, we can let the compiler do this annoying parameter forwarding:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-Control-flow"><a href="#2-4-Control-flow" class="headerlink" title="2.4 Control flow"></a>2.4 Control flow</h2><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h3><p>As we saw at the beginning of this chapter, we know that C++11 introduces the <code>constexpr</code> keyword, which compiles expressions or functions into constant results. A natural idea is that if we introduce this feature into the conditional judgment, let the code complete the branch judgment at compile-time, can it make the program more efficient? C++17 introduces the <code>constexpr</code> keyword into the <code>if</code> statement, allowing you to declare the condition of a constant expression in your code. Consider the following code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At compile time, the actual code will behave as follows:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">print_type_info</span>(<span class="number">3.14</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range-based-for-loop"><a href="#Range-based-for-loop" class="headerlink" title="Range-based for loop"></a>Range-based for loop</h3><p>Finally, C++11 introduces a range-based iterative method, and we can write loops that are as concise
as Python, and we can further simplify the previous example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>); itr != vec.<span class="built_in">end</span>()) *itr = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;                      <span class="comment">// writeable</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; std::endl; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-Templates"><a href="#2-5-Templates" class="headerlink" title="2.5 Templates"></a>2.5 Templates</h2><p>C++ templates have always been a special art of the language, and templates can even be used independently as a new language. The philosophy of the template is to throw all the problems that can be processed at compile time into the compile time, and only deal with those core dynamic services at runtime, to greatly optimize the performance of the runtime. Therefore, templates are also regarded by many as one of the black magic of C++.</p>
<h3 id="Extern-templates"><a href="#Extern-templates" class="headerlink" title="Extern templates"></a>Extern templates</h3><p>In traditional C++, templates are instantiated by the compiler only when they are used. In other words, as long as a fully defined template is encountered in the code compiled in each compilation unit (file), it will be instantiated. This results in an increase in compile time due to repeated instantiations. Also, we have no way to tell the compiler not to trigger the instantiation of the template.</p>
<p>To this end, C++11 introduces an external template that extends the syntax of the original mandatory compiler to instantiate a template at a specific location, allowing us to explicitly tell the compiler when to instantiate the template:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:vector&lt;<span class="keyword">bool</span>&gt;;          <span class="comment">// force instantiation</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:vector&lt;<span class="keyword">double</span>&gt;; <span class="comment">// should not instantiation in current file</span></span><br></pre></td></tr></table></figure>

<h3 id="The-quot-gt-quot"><a href="#The-quot-gt-quot" class="headerlink" title="The &quot;&gt;&quot;"></a>The &quot;&gt;&quot;</h3><p>In the traditional C++ compiler, <code>&gt;&gt;</code> is always treated as a right shift operator. But actually we can easily write the code for the nested template:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;<span class="keyword">int</span>&gt;&gt; matrix;</span><br></pre></td></tr></table></figure>

<p>This is not compiled under the traditional C++ compiler,
and C++11 starts with continuous right angle brackets that become legal
and can be compiled successfully.
Even the following writing can be compiled by:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicType</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> magic = T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in main function:</span></span><br><span class="line">std::vector&lt;MagicType&lt;(1&gt;<span class="number">2</span>)&gt;&gt; magic; <span class="comment">// legal, but not recommended</span></span><br></pre></td></tr></table></figure>

<h3 id="Type-alias-templates"><a href="#Type-alias-templates" class="headerlink" title="Type alias templates"></a>Type alias templates</h3><p>Before you understand the type alias template, you need to understand the difference between &quot;template&quot; and &quot;type&quot;. Carefully understand this sentence: <strong>Templates are used to generate types.</strong> In traditional C++, <code>typedef</code> can define a new name for the type, but there is no way to define a new name for the template. Because the template is not a type. E.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T dark;</span><br><span class="line">    U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not allowed</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;std::vector&lt;T&gt;, std::string&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure>

<p>C++11 uses <code>using</code> to introduce the following form of writing, and at the same time supports the same effect as the traditional <code>typedef</code>:</p>
<blockquote>
<p>Usually, we use <code>typedef</code> to define the alias syntax: <code>typedef original name new name; </code>, but the definition syntax for aliases such as function pointers is different, which usually causes a certain degree of difficulty for direct reading.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="built_in"><span class="keyword">int</span></span>(*)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;std::vector&lt;T&gt;, std::string&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TrueDarkMagic&lt;<span class="keyword">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Variadic-templates"><a href="#Variadic-templates" class="headerlink" title="Variadic templates"></a>Variadic templates</h3><p>The template has always been one of C++&#39;s unique <strong>Black Magic</strong>.
In traditional C++,
both a class template and a function template could only accept
a fixed set of template parameters as specified;
C++11 added a new representation, allowing any number,
template parameters of any category,
and there is no need to fix the number of parameters when defining.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br></pre></td></tr></table></figure>

<p>The template class Magic object can accept an unrestricted number of typename as
a formal parameter of the template, such as the following definition:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span><span class="keyword">int</span>,</span><br><span class="line">            std::vector&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line">            std::map&lt;std::string,</span><br><span class="line">            std::vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; darkMagic;</span><br></pre></td></tr></table></figure>

<p>Since it is arbitrary, a template parameter with a number of 0 is also possible: <code>class Magic&lt;&gt; nothing;</code>.</p>
<p>If you do not want to generate 0 template parameters, you can manually define at least one template parameter:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Require, <span class="keyword">typename</span>... Args&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br></pre></td></tr></table></figure>

<p>The variable length parameter template can also be directly adjusted to the template function.
The <code>printf</code> function in the traditional C, although it can also reach the call of an indefinite number of formal parameters, is not class safe. In addition to the variable-length parameter functions that define class safety, C++11 can also make printf-like functions naturally handle objects that are not self-contained. In addition to the use of <code>...</code> in the template parameters to indicate the indefinite length of the template parameters, the function parameters also use the same representation to represent the indefinite length parameters, which provides a convenient means for us to simply write variable length parameter functions, such as:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt; <span class="keyword">void</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> std::string &amp;str, Args... args)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Then we define variable length template parameters,
how to unpack the parameters?</p>
<p>First, we can use <code>sizeof...</code> to calculate the number of arguments:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We can pass any number of arguments to the <code>magic</code> function:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">magic</span>();      <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>);     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">magic</span>(<span class="number">1</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>Second, the parameters are unpacked. So far there is no simple way to process
the parameter package, but there are two classic processing methods:</p>
<p><strong>1. Recursive template function</strong></p>
<p>Recursion is a very easy way to think of and the most classic approach. This method continually recursively passes template parameters to the function, thereby achieving the purpose of recursively traversing all template parameters:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">printf1</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. Variable parameter template expansion</strong></p>
<p>You should feel that this is very cumbersome. Added support for variable parameter template expansion in C++17, so you can write <code>printf</code> in a function:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t0 &lt;&lt; std::endl;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>In fact, sometimes we use variable parameter templates, but we don&#39;t necessarily need to traverse the parameters one by one. We can use the features of <code>std::bind</code> and perfect forwarding to achieve the binding of functions and parameters, thus achieving success. The purpose of the call.</p>
</blockquote>
<p><strong>3. Initialize list expansion</strong></p>
<p>Recursive template functions are standard practice, but the obvious drawback is that you must define a function that terminates recursion.</p>
<p>Here is a description of the black magic that is expanded using the initialization list:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    (<span class="keyword">void</span>) std::initializer_list&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line">        std::cout &lt;&lt; args &lt;&lt; std::endl;</span><br><span class="line">    &#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this code, the initialization list provided in C++11 and the properties of the Lambda expression (mentioned in the next section) are additionally used.</p>
<p>By initializing the list, <code>(lambda expression, value)...</code> will be expanded. Due to the appearance of the comma expression, the previous lambda expression is executed first, and the output of the parameter is completed.
To avoid compiler warnings, we can explicitly convert <code>std::initializer_list</code> to <code>void</code>.</p>
<h3 id="Fold-expression"><a href="#Fold-expression" class="headerlink" title="Fold expression"></a>Fold expression</h3><p>In C++ 17, this feature of the variable length parameter is further brought to the expression, consider the following example:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ... T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(T ... t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Non-type-template-parameter-deduction"><a href="#Non-type-template-parameter-deduction" class="headerlink" title="Non-type template parameter deduction"></a>Non-type template parameter deduction</h3><p>What we mainly mentioned above is a form of template parameters: type template parameters.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The parameters of the template <code>T</code> and <code>U</code> are specific types.
But there is also a common form of template parameter that allows different literals
to be template parameters, i.e. non-type template parameters:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer_t</span>&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 as template parameter</span></span><br></pre></td></tr></table></figure>

<p>In this form of template parameters, we can pass <code>100</code> as a parameter to the template.
After C++11 introduced the feature of type derivation, we will naturally ask, since the template parameters here.
Passing with a specific literal, can the compiler assist us in type derivation,
By using the placeholder <code>auto</code>, there is no longer a need to explicitly specify the type?
Fortunately, C++17 introduces this feature, and we can indeed use the <code>auto</code> keyword to let the compiler assist in the completion of specific types of derivation.
E.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo&lt;<span class="number">10</span>&gt;();  <span class="comment">// value as int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-Object-oriented"><a href="#2-6-Object-oriented" class="headerlink" title="2.6 Object-oriented"></a>2.6 Object-oriented</h2><h3 id="Delegate-constructor"><a href="#Delegate-constructor" class="headerlink" title="Delegate constructor"></a>Delegate constructor</h3><p>C++11 introduces the concept of a delegate construct, which allows a constructor to call another constructor
in a constructor in the same class, thus simplifying the code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// delegate Base() constructor</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; b.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; b.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Inheritance-constructor"><a href="#Inheritance-constructor" class="headerlink" title="Inheritance constructor"></a>Inheritance constructor</h3><p>In traditional C++, constructors need to pass arguments one by one if they need inheritance, which leads to inefficiency. C++11 introduces the concept of inheritance constructors using the keyword using:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value1;</span><br><span class="line">    <span class="keyword">int</span> value2;</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        value1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="keyword">int</span> value) : <span class="built_in">Base</span>() &#123; <span class="comment">// delegate Base() constructor</span></span><br><span class="line">        value2 = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base; <span class="comment">// inheritance constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; s.value1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; s.value2 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Explicit-virtual-function-overwrite"><a href="#Explicit-virtual-function-overwrite" class="headerlink" title="Explicit virtual function overwrite"></a>Explicit virtual function overwrite</h3><p>In traditional C++, it is often prone to accidentally overloading virtual functions. E.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>SubClass::foo</code> may not be a programmer trying to overload a virtual function, just adding a function with the same name. Another possible scenario is that when the virtual function of the base class is deleted, the subclass owns the old function and no longer overloads the virtual function and turns it into a normal class method, which has catastrophic consequences.</p>
<p>C++11 introduces the two keywords <code>override</code> and <code>final</code> to prevent this from happening.</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>When overriding a virtual function, introducing the <code>override</code> keyword will explicitly tell the compiler to overload, and the compiler will check if the base function has such a virtual function with consistent function signature, otherwise it will not compile:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// legal</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// illegal, no virtual function in super class</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><code>final</code> is to prevent the class from being continued to inherit and to terminate
the virtual function to continue to be overloaded.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="keyword">final</span>:</span> Base &#123;</span><br><span class="line">&#125;; <span class="comment">// legal</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// illegal, SubClass1 has final</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// illegal, foo has final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Explicit-delete-default-function"><a href="#Explicit-delete-default-function" class="headerlink" title="Explicit delete default function"></a>Explicit delete default function</h3><p>In traditional C++, if the programmer does not provide it, the compiler will default to generating default constructors, copy constructs, assignment operators, and destructors for the object. Besides, C++ also defines operators such as <code>new</code> <code>delete</code> for all classes. This part of the function can be overridden when the programmer needs it.</p>
<p>This raises some requirements: the ability to accurately control the generation of default functions cannot be controlled. For example, when copying a class is prohibited, the copy constructor and the assignment operator must be declared as <code>private</code>. Trying to use these undefined functions will result in compilation or link errors, which is a very unconventional way.</p>
<p>Also, the default constructor generated by the compiler cannot exist at the same time as the user-defined constructor. If the user defines any constructor, the compiler will no longer generate the default constructor, but sometimes we want to have both constructors at the same time, which is awkward.</p>
<p>C++11 provides a solution to the above requirements, allowing explicit declarations to take or reject functions that come with the compiler. E.g:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Magic</span>() = <span class="keyword">default</span>; <span class="comment">// explicit let compiler use default constructor</span></span><br><span class="line">    Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// explicit declare refuse constructor</span></span><br><span class="line">    <span class="built_in">Magic</span>(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Strongly-typed-enumerations"><a href="#Strongly-typed-enumerations" class="headerlink" title="Strongly typed enumerations"></a>Strongly typed enumerations</h3><p>In traditional C++, enumerated types are not type-safe, and enumerated types are treated as integers, which allows two completely different enumerated types to be directly compared (although the compiler gives the check, but not all), ** Even the enumeration value names of different enum types in the same namespace cannot be the same**, which is usually not what we want to see.</p>
<p>C++11 introduces an enumeration class and declares it using the syntax of <code>enum class</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">    value1,</span><br><span class="line">    value2,</span><br><span class="line">    value3 = <span class="number">100</span>,</span><br><span class="line">    value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The enumeration thus defined implements type safety. First, it cannot be implicitly converted to an integer, nor can it be compared to integer numbers, and it is even less likely to compare enumerated values of different enumerated types. But if the values specified are the same between the same enumerated values, then you can compare:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4) &#123; <span class="comment">// true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In this syntax, the enumeration type is followed by a colon and a type keyword to specify the type of the enumeration value in the enumeration, which allows us to assign a value to the enumeration (int is used by default when not specified).</p>
<p>And we want to get the value of the enumeration value, we will have to explicitly type conversion, but we can overload the <code>&lt;&lt;</code> operator to output, you can collect the following code snippet:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;std::is_enum&lt;T&gt;::value,</span><br><span class="line">        std::ostream&gt;::type&amp; stream, <span class="keyword">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>At this point, the following code will be able to be compiled:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; new_enum::value3 &lt;&lt; std::endl</span><br></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This section introduces the enhancements to language usability in modern C++, which I believe are the most important features that almost everyone needs to know and use:</p>
<ol>
<li>Auto type derivation</li>
<li>Scope for iteration</li>
<li>Initialization list</li>
<li>Variable parameter template</li>
</ol>
<h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li><p>Using structured binding, implement the following functions with just one line of function code:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(std::map&lt;Key, Value&gt;&amp; m, F foo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::map&lt;std::string, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>&gt; m &#123;</span><br><span class="line">        &#123;<span class="string">&quot;a&quot;</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;b&quot;</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;c&quot;</span>, <span class="number">3</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">update</span>(m, [](std::string key) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::hash&lt;std::string&gt;&#123;&#125;(key);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; [key, value] : m)</span><br><span class="line">        std::cout &lt;&lt; key &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Try to implement a function for calculating the mean with <a href="#Fold-expression">Fold Expression</a>, allowing any arguments to be passed in.</p>
</li>
</ol>
<blockquote>
<p>Refer to the answer <a href="../../exercises/2">see this</a>.</p>
</blockquote>

  <div class="guide-links">
    
      <span>← <a href="/modern-cpp/en-us/01-intro/index.html">Chapter 01: Towards Modern C++</a></span>
    
    
      <span style="float: right;"><a href="/modern-cpp/en-us/03-runtime/index.html">Chapter 03: Language Runtime Enhancements</a> →</span>
    
  </div>

  
    <div class="footer">
        <p>
          <a href="https://changkun.de">Changkun Ou</a> &copy; 2016-2025.
          The book is licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons Attribution-NonCommercial-NoDerivatives 4.0</a>, code is open sourced under the <a href="https://opensource.org/licenses/MIT" target="_blank">MIT</a> License. </a>
        </p>
        <p>
          If you like the book, you could <a href="/modern-cpp/about/donate.html">donate the author</a>.
        </p>
      </div>
  


</div>

      </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smooth-scroll/10.2.1/js/smooth-scroll.min.js"></script>

    <!-- main custom script for sidebars, version selects etc. -->
    <script src="https://cdn.jsdelivr.net/npm/css.escape@1.5.1/css.escape.min.js"></script>
    <script src="/modern-cpp/js/common.js"></script>

    <!-- fastclick -->
    <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
    <script>
    document.addEventListener('DOMContentLoaded', function() {
      FastClick.attach(document.body)
    }, false)
    </script>
  </body>
</html>
